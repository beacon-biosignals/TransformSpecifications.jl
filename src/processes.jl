#####
##### `AbstractTransformSpecification`
#####

"""
    abstract type AbstractTransformSpecification

Transform specifications are represented by subtypes of `AbstractTransformSpecification`.
Each leaf should be immutable and define methods for
- [`input_schema](@ref)` returns type expected/allowed as transform input
- [`output_schema](@ref)` returns output type generated by successfully completed processing
- [`apply!`](@ref), which performs processing on an input record of type `input_schema`
    and returns an output of type `output_schema`
"""
abstract type AbstractTransformSpecification end
# TODO-future: add/document mutation of transform input

"""
    apply!(process::AbstractTransformSpecification, input_record) -> TransformSpecificationResult

Return result of applying `process` to an `input_record` of type `process.input_schema`,
where result is `TransformSpecificationResult` with output record type `process.output_record`.
"""
function apply! end

"""
    input_schema(process::AbstractTransformSpecification) -> Type{<:Legolas.AbstractRecord}

Return Legolas schema of record accepted as input to `process`.
"""
function input_schema end

"""
    output_schema(process::AbstractTransformSpecification) -> Type{<:Legolas.AbstractRecord}

Return Legolas schema of record returned by successful `process` application.
"""
function output_schema end

"""
    TransformSpecificationResult(; warnings::Union{String,Vector{String}}=String[],
                         violations::Union{String,Vector{String}}=String[],
                         record=missing)
    TransformSpecificationResult(record; kwargs...)

Results of an [`AbstractTransformSpecification`](@ref), indicating success of a process through
presence (or lack thereof) of `violations`.

Must contain either a non-`missing` `record` or a non-empty `violations`, although
non-empty `violations` does not mean that `record` is necessarily `missing`.

See also: [`process_succeeded`](@ref)

## Fields

- `warnings::Vector{String}`: List of generated warnings that are not critical enough to be `violations`.
- `violations::Vector{String}` List of reason(s) `record` was not able to be generated.
- `record::`: Generated `record`; `missing` if any `violations` encountered.

## Example

```jldoctest
julia> @schema "example" ExampleSchema
julia> @version ExampleSchemaV1 begin
    name::String
end

julia> TransformSpecificationResult(ExampleSchemaV1(; name="yeehaw"))
TransformSpecificationResult: Process succeeded
  ✅ record: ExampleSchemaV1:
 :name  "yeehaw"

julia> TransformSpecificationResult(ExampleSchemaV1(; name="huzzah"); warnings="Hark, watch your step...")
TransformSpecificationResult: Process succeeded
  ⚠️  Hark, watch your step...
  ☑️  record: ExampleSchemaV1:
 :name  "huzzah"

julia> TransformSpecificationResult(; violations=["Epic fail!", "Slightly less epic fail!"], warnings=["Uh oh..."])
TransformSpecificationResult: Process failed
  ❗ Epic fail!
  ❗ Slightly less epic fail!
  ⚠️  Uh oh...
  ❌ record: missing

julia> TransformSpecificationResult(; violations=["Epic fail!", "Slightly less epic fail!"], warnings=["Uh oh..."], record=ExampleSchemaV1(; name="woo"))
TransformSpecificationResult: Process failed
  ❗ Epic fail!
  ❗ Slightly less epic fail!
  ⚠️  Uh oh...
  ☑️  record: ExampleSchemaV1:
 :name  "woo"
```
"""
struct TransformSpecificationResult{T<:Union{Missing,<:Legolas.AbstractRecord}}
    warnings::Vector{String}
    violations::Vector{String}
    record::T

    function TransformSpecificationResult(; warnings::Union{String,Vector{String}}=String[],
                                          violations::Union{String,Vector{String}}=String[],
                                          record::Union{Missing,<:Legolas.AbstractRecord}=missing)
        if ismissing(record) && isempty(violations)
            throw(ArgumentError("Invalid args: either `record` must be non-missing OR `violations` must be non-empty."))
        end
        warnings isa Vector{String} || (warnings = [warnings])
        violations isa Vector{String} || (violations = [violations])
        return new{typeof(record)}(warnings, violations, record)
    end
end

function TransformSpecificationResult(record; warnings=String[], violations=String[])
    return TransformSpecificationResult(; record, warnings, violations)
end

"""
    process_succeeded(result::TransformSpecificationResult) -> Bool

Return `true` if `result` indicates successful completion, i.e. if `result.violations`
is empty.

See also: [`TransformSpecificationResult`](@ref)
"""
process_succeeded(result::TransformSpecificationResult) = isempty(result.violations)

function Base.show(io::IO, r::TransformSpecificationResult)
    succeeded = process_succeeded(r)
    str = "TransformSpecificationResult: Process $(succeeded ? "succeeded" : "failed")\n"
    for v in r.violations
        str *= "  ❗ $v\n"
    end
    for w in r.warnings
        str *= "  ⚠️  $w\n"
    end
    bullet = ismissing(r.record) ? "❌" : (succeeded ? "✅" : "☑️ ")
    str *= "  $bullet record: $(r.record)"
    return print(io, str)
end

#####
##### `TransformSpecification`
#####

"""
    TransformSpecification <: AbstractTransformSpecification

Basic processing component that converts input record with schema
`input_schema` to a [`TransformSpecificationResult`](@ref) with record type `output_schema`,
via `apply_fn`.

## Fields

- `input_schema::Type{<:Legolas.AbstractRecord}`
- `output_schema::Type{<:Legolas.AbstractRecord}`
- `apply_fn::Function` Function with signature `apply_fn(::input_schema) -> TransformSpecificationResult{output_schema}`

## Example

```jldoctest
julia> @schema "example-in" ExampleInSchema
julia> @version ExampleInSchemaV1 begin
    in_name::String
end

julia> @schema "example-out" ExampleOutSchema
julia> @version ExampleOutSchemaV1 begin
    out_name::String
end

julia> function apply_example(in_record)
    out_name = in_record.in_name * "_earthling"
    return TransformSpecificationResult(ExampleOutSchemaV1(; out_name))
end
julia> p = TransformSpecification(ExampleInSchemaV1, ExampleOutSchemaV1, apply_example)
TransformSpecification (input: ExampleInSchemaV1; output: ExampleOutSchemaV1; process: apply_example)

julia> apply!(p, ExampleInSchemaV1(; in_name="greetings"))
TransformSpecificationResult: Process succeeded
  ✅ record: ExampleOutSchemaV1:
 :out_name  "greetings_earthling"

julia> force_failure_example(in_record) = TransformSpecificationResult(; violations=["womp", "womp"])

julia> p = TransformSpecification(ExampleInSchemaV1, ExampleOutSchemaV1, force_failure_example)
TransformSpecification (input: ExampleInSchemaV1; output: ExampleOutSchemaV1; process: force_failure_example)

julia> apply!(p, ExampleInSchemaV1(; in_name="greetings"))
TransformSpecificationResult: Process failed
  ❗ womp
  ❗ womp
  ❌ record: missing
```
"""
Base.@kwdef struct TransformSpecification <: AbstractTransformSpecification
    input_schema::Type{<:Legolas.AbstractRecord}
    output_schema::Type{<:Legolas.AbstractRecord}
    apply_fn::Function  # TODO-help: how to validate the function signature (in type or on construction), to ensure takes in input schema as specified, spits out output schema?
end
#= TODO-decide: should we make this parametric on input and output schema?? could be kinda cool...
# e.g.
Base.@kwdef struct TransformSpecification{T,U} where {T<:Type{<:Legolas.AbstractRecord}, U<:Type{<:Legolas.AbstractRecord}} <: AbstractTransformSpecification
    input_schema::T
    output_schema::U
    apply_fn::Function
end
=#

#TODO-decide: do we want to enforce `input_record` type? how, if we wanted to?
"""
    apply!(process::TransformSpecification, input_record)

Return [`TransformSpecificationResult`](@ref) of applying `process.apply_fn` to `input_record`.
"""
function apply!(process::TransformSpecification, input_record)
    try
        # Check that input conforms to input schema (doesn't matter if it _actually_
        # is of the same schema type, or a child, or whatever. if it conforms? it's valid.)
        # TODO-help: is there a better way to do this? e.g. to use Legolas.find_violations instead of this?
        process.input_schema(input_record)
    catch e
        return TransformSpecificationResult(;
                                            violations="Record doesn't conform to input schema $(process.input_schema). Details: " *
                                                       string(e))
    end
    return process.apply_fn(input_record)
end

input_schema(process::TransformSpecification) = process.input_schema
output_schema(process::TransformSpecification) = process.output_schema

function Base.show(io::IO, p::TransformSpecification)
    return print(io,
                 "TransformSpecification (input: $(p.input_schema); output: $(p.output_schema); process: $(p.apply_fn))")
end

"""
    identity_legolas_process(io_schema::Type{<:Legolas.AbstractRecord}) -> TransformSpecification{io_schema}

Create [`TransformSpecification`](@ref) where `input_schema==output_schema` and `apply_fn`
result is a `TransformSpecificationResult{io_schema}`.

Required to be the first element in a [`TransformSpecificationChain`](@ref).

See also: [`is_identity_process`](@ref)
"""
function identity_legolas_process(io_schema::Type{<:Legolas.AbstractRecord})
    return TransformSpecification(io_schema, io_schema, identity_process_result_transform)
end

#TODO-help: i don't really want to have to define a function for this, I want to
# `just` use `TransformSpecificationResult` instead of a defined function from w/in `identity_legolas_process`, but the construtor for
# TransformSpecificationResult is not recognized as conforming to the `::Function` type on contruction :(
# TODO: ALSO the name for this is terrible. hold off on bikeshedding until overall package rename is complete
function identity_process_result_transform(io_schema::Type{<:Legolas.AbstractRecord})
    return TransformSpecificationResult(r)
end

"""
    is_identity_process(process::TransformSpecification) -> Bool

Check if `process` meets the definition of an [`identity_legolas_process`](@ref).
"""
function is_identity_process(process::TransformSpecification)
    if input_schema(process) != output_schema(process)
        @debug "Input and output schemas are not identical: $process"
        return false
    end
    is_identity = isequal(process.apply_fn, identity_process_result_transform)
    if !is_identity
        @debug "`apply_fn` is not `identity_process_result_transform`"
    end
    return is_identity
end

#####
##### `TransformSpecificationChain`
#####

"""
    TransformSpecificationChain <: AbstractTransformSpecification
    TransformSpecificationChain(steps::Vector{<:Tuple{Symbol,AbstractTransformSpecification, Function}})

Processing component that runs a sequence of [`AbstractTransformSpecification`](@ref) `process_steps`,
by [`apply!`](@ref)ing each step in order. The chain's `input_schema` is that of the
first element in `process_steps`; the chain's `output_schema` is that of the last
element in the `process_steps`.

The `process_steps` are stored internally as an `OrderedDict{:Symbol,AbstractTransformSpecification}`
of `<step name> => <step process>`, along with the instructions (`input_constructors`)
for constructing the input to each step as a function of all previous ouput component
results. Each key in `process_steps` has a corresponding key in `input_constructors`.
(This input construction approach/type may change in an upcoming release.)

The constructor that takes in series of `steps` expects steps to take the format
`(name, process, input_constructor)`.

To grant downstream access to all fields passed into the first step, the first step should
be an identity process, i.e., `is_identity_process(step)` should return true. Additionally,
the first step receives input directly from the overall process chain input, so
does not construct its own input; its input construction function must therefore by `nothing`.

!!! warn
    It is the caller's responsibility to only implement a DAG, and to not introduce
    recursion by constructing a chain that includes that same chain as a processing
    step! To quote Tom Lehrer, "[you ask a silly question, you get a silly answer](https://youtu.be/zWPn3esuDgU?t=189)."

## Fields

- `process_steps::OrderedDict{Symbol,AbstractTransformSpecification}` Ordered processing steps
- `input_constructors::Dict{Symbol,Function}` Dictionary with functions for constructing the input
    for each key in `process_steps` as a function that takes in a Dict{Symbol,TransformSpecificationResult}
    of all upstream `process_steps` results.

## Example

TODO-future
```jldoctest
```
"""
struct TransformSpecificationChain <: AbstractTransformSpecification
    process_steps::OrderedDict{Symbol,AbstractTransformSpecification}
    input_constructors::Dict{Symbol,Union{Nothing,Function}}

    function TransformSpecificationChain(process_steps::OrderedDict,
                                         input_constructors::Dict)
        first_key = first(keys(process_steps))
        constructor_keys = push!(Set(collect(keys(input_constructors))), first_key)
        if !issetequal(keys(process_steps), constructor_keys)
            a = collect(setdiff(keys(process_steps), keys(input_constructors)))
            b = collect(setdiff(keys(input_constructors), keys(process_steps)))
            str = "Mismatch in chain steps:"
            isempty(a) ||
                (str *= "\n- Keys present in `process_steps` are missing in `input_constructors`: $a")
            isempty(b) ||
                (str *= "\n- Keys present in `input_constructors` are missing in `input_constructors`: $b")
            throw(ArgumentError(str))
        end
        if haskey(input_constructors, first_key) &&
           !isnothing(input_constructors[first_key])
            throw(ArgumentError("First step's input constructor must be `nothing`"))
        end
        # TODO: validate input_constructors dag!
        # TODO: other validation!
        return new(process_steps, input_constructors)
    end
end

const AbstractProcessChainStep = Tuple{Symbol,AbstractTransformSpecification,
                                       Union{Nothing,Function}}

function TransformSpecificationChain(steps::Vector{<:AbstractProcessChainStep})
    process_steps = OrderedDict{Symbol,AbstractTransformSpecification}()
    input_constructors = Dict{Symbol,Union{Nothing,Function}}()
    for step in steps
        _add_step_to_chain(process_steps, input_constructors, step)
    end
    return TransformSpecificationChain(process_steps, input_constructors)
end

function _add_step_to_chain(process_steps::OrderedDict{Symbol,
                                                       AbstractTransformSpecification},
                            input_constructors::Dict{Symbol,Union{Nothing,Function}},
                            step::AbstractProcessChainStep)
    (key, process, input_constructor) = step
    haskey(process_steps, key) &&
        throw(ArgumentError("Key `$key` already exists in chain!"))
    push!(process_steps, key => process)
    push!(input_constructors, key => input_constructor) #TODO: first validate that these are possible...
    return nothing
end

function Base.append!(chain::TransformSpecificationChain, step::AbstractProcessChainStep)
    return _add_step_to_chain(chain.process_steps, chain.input_constructors, step)
end

"""
    input_schema(chain::TransformSpecificationChain) -> Type{<:Legolas.AbstractRecord}

Return Legolas schema of record accepted as input to first process in `chain.process_steps`.
"""
input_schema(c::TransformSpecificationChain) = first(c.process_steps)[2].input_schema

"""
    output_schema(chain::TransformSpecificationChain) -> Type{<:Legolas.AbstractRecord}

Return Legolas schema of record returned by last process in `chain.process_steps`,
which is the record returned by successful application of the entire chain.
"""
output_schema(c::TransformSpecificationChain) = last(c.process_steps)[2].output_schema

"""
    apply!(chain::TransformSpecificationChain, input_record)

Return [`TransformSpecificationResult`](@ref) of sequentially `apply!`ing all `chain.process_steps`
to `input_record`.

Before each step (`key`), the step's `chain.input_constructors[key]` is called
on the results of all previous processing steps, in order to construct input to
the step that conforms to the step's requisite `input_schema(process)`.

Initial step does not call input construction for itself, as chain input is passed directly
into it.
"""
function apply!(chain::TransformSpecificationChain, input_record)
    warnings = String[]
    component_results = OrderedDict{Symbol,Legolas.AbstractRecord}()
    for (i_process, (name, process)) in enumerate(chain.process_steps)
        @debug "Applying component `$name`..."
        input_record = if i_process == 1
            # The initial input record does not need to be constructed---it already
            # exists. (Is it valid? Who knows---but the `apply!` function will handle
            # that validation below!)
            input_record
        else
            # Construct
            input_nt = chain.input_constructors[name](component_results)

            # prob don't need this try/catch, can pass into the function as a named tuple...
            try
                process.input_schema(; input_nt...)
            catch e
                return TransformSpecificationResult(; warnings,
                                                    violations=["Process $name failed: $e"])
            end
        end
        result = apply!(process, input_record)

        # Compile results
        append!(warnings, result.warnings)
        isempty(result.violations) ||
            return TransformSpecificationResult(; warnings, result.violations)
        component_results[name] = result.record
    end
    return TransformSpecificationResult(; warnings, record=last(component_results)[2])
end

function Base.show(io::IO, c::TransformSpecificationChain)
    str = "TransformSpecificationChain:\n"
    for (i, (k, v)) in enumerate(c.process_steps)
        bullet = i == 1 ? "🌱" : (i == length(c.process_steps) ? "🌷" : "☀️")
        str *= "  $bullet  $k ($(v.input_schema) => $(v.output_schema))\n"
    end
    return print(io, str)
end
# TODO-future: support applying subsets of processing chain, with `init` option for passing in "upstream outputs" results
# TODO-future: define where validation happens in this chain, and how

#####
##### Shared utilities
#####

for pred in (:(==), :(isequal)),
    T in
    [AbstractTransformSpecification, TransformSpecificationResult, TransformSpecification,
     TransformSpecificationChain]

    @eval function Base.$pred(x::$T, y::$T)
        return all(p -> $pred(getproperty(x, p), getproperty(y, p)), fieldnames($T))
    end
end
# TODO-help: do we need a hash function for these as well?

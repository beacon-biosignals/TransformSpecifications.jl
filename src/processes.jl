#####
##### `AbstractLegolasProcess`
#####

"""
    abstract type AbstractLegolasProcess

Legolas processes are represented by subtypes of `AbstractLegolasProcess`.
Each leaf should be immutable and define methods for
- [`input_schema](@ref)` returns Legolas schema expected/allowed as process input
- [`output_schema](@ref)` returns Legolas schema generated by successfully completed processing
- [`apply!`](@ref), which performs processing on an input record of type `input_schema`
    and returns a [`LegolasProcessResult`](@ref) with output record of type `output_schema`
"""
abstract type AbstractLegolasProcess end
# TODO-future: add/document required validation fields/methods
# TODO-future: add/document mutation effect on input schema fields

"""
    apply!(process::AbstractLegolasProcess, input_record) -> LegolasProcessResult

Return result of applying `process` to an `input_record` of type `process.input_schema`,
where result is `LegolasProcessResult` with output record type `process.output_record`.
"""
function apply! end

"""
    input_schema(process::AbstractLegolasProcess) -> Type{<:Legolas.AbstractRecord}

Return Legolas schema of record accepted as input to `process`.
"""
function input_schema end

"""
    output_schema(process::AbstractLegolasProcess) -> Type{<:Legolas.AbstractRecord}

Return Legolas schema of record returned by successful `process` application.
"""
function output_schema end

"""
    LegolasProcessResult(; warnings::Union{String,Vector{String}}=String[],
                         violations::Union{String,Vector{String}}=String[],
                         record=missing)
    LegolasProcessResult(record; kwargs...)

Results of an [`AbstractLegolasProcess`](@ref), indicating success of a process through
presence (or lack thereof) of `violations`.

Must contain either a non-`missing` `record` or a non-empty `violations`, although
non-empty `violations` does not mean that `record` is necessarily `missing`.

See also: [`process_succeeded`](@ref)

## Fields

- `warnings::Vector{String}`: List of generated warnings that are not critical enough to be `violations`.
- `violations::Vector{String}` List of reason(s) `record` was not able to be generated.
- `record::`: Generated `record`; `missing` if any `violations` encountered.

## Example

```jldoctest
julia> @schema "example" ExampleSchema
julia> @version ExampleSchemaV1 begin
    name::String
end

julia> LegolasProcessResult(ExampleSchemaV1(; name="yeehaw"))
LegolasProcessResult: Process succeeded
  ✅ record: ExampleSchemaV1:
 :name  "yeehaw"

julia> LegolasProcessResult(ExampleSchemaV1(; name="huzzah"); warnings="Hark, watch your step...")
LegolasProcessResult: Process succeeded
  ⚠️  Hark, watch your step...
  ☑️  record: ExampleSchemaV1:
 :name  "huzzah"

julia> LegolasProcessResult(; violations=["Epic fail!", "Slightly less epic fail!"], warnings=["Uh oh..."])
LegolasProcessResult: Process failed
  ❗ Epic fail!
  ❗ Slightly less epic fail!
  ⚠️  Uh oh...
  ❌ record: missing

julia> LegolasProcessResult(; violations=["Epic fail!", "Slightly less epic fail!"], warnings=["Uh oh..."], record=ExampleSchemaV1(; name="woo"))
LegolasProcessResult: Process failed
  ❗ Epic fail!
  ❗ Slightly less epic fail!
  ⚠️  Uh oh...
  ☑️  record: ExampleSchemaV1:
 :name  "woo"
```
"""
#TODO-help: how do i get the type here to be `LegolasProcessResult{T}` with `record::Union{T,Missing}`?
struct LegolasProcessResult
    warnings::Vector{String}
    violations::Vector{String}
    record::Union{Legolas.AbstractRecord,Missing}

    function LegolasProcessResult(; warnings::Union{String,Vector{String}}=String[],
                                  violations::Union{String,Vector{String}}=String[],
                                  record=missing)
        if ismissing(record) && isempty(violations)
            throw(ArgumentError("Invalid args: either `record` must be non-missing OR `violations` must be non-empty."))
        end
        warnings isa Vector{String} || (warnings = [warnings])
        violations isa Vector{String} || (violations = [violations])
        return new(warnings, violations, record)
    end
end

LegolasProcessResult(record; kwargs...) = LegolasProcessResult(; record, kwargs...)

"""
    process_succeeded(result::LegolasProcessResult) -> Bool

Return `true` if `result` indicates successful completion, i.e. if `result.violations`
is empty.

See also: [`LegolasProcessResult`](@ref)
"""
process_succeeded(result::LegolasProcessResult) = isempty(result.violations)

function Base.show(io::IO, r::LegolasProcessResult)
    succeeded = process_succeeded(r)
    str = "LegolasProcessResult: Process $(succeeded ? "succeeded" : "failed")\n"
    for v in r.violations
        str *= "  ❗ $v\n"
    end
    for w in r.warnings
        str *= "  ⚠️  $w\n"
    end
    bullet = ismissing(r.record) ? "❌" : (succeeded ? "✅" : "☑️ ")
    str *= "  $bullet record: $(r.record)"
    return print(io, str)
end

#####
##### `LegolasProcess`
#####

"""
    LegolasProcess <: AbstractLegolasProcess

Basic processing component that converts input record with schema
`input_schema` to a [`LegolasProcessResult`](@ref) with record type `output_schema`,
via `apply_fn`.

## Fields

- `input_schema::Type{<:Legolas.AbstractRecord}`
- `output_schema::Type{<:Legolas.AbstractRecord}`
- `apply_fn::Function` Function with signature `apply_fn(::input_schema) -> LegolasProcessResult{output_schema}`

## Example

```jldoctest
julia> @schema "example-in" ExampleInSchema
julia> @version ExampleInSchemaV1 begin
    in_name::String
end

julia> @schema "example-out" ExampleOutSchema
julia> @version ExampleOutSchemaV1 begin
    out_name::String
end

julia> function apply_example(in_record)
    out_name = in_record.in_name * "_earthling"
    return LegolasProcessResult(ExampleOutSchemaV1(; out_name))
end
julia> p = LegolasProcess(ExampleInSchemaV1, ExampleOutSchemaV1, apply_example)
LegolasProcess (input: ExampleInSchemaV1; output: ExampleOutSchemaV1; process: apply_example)

julia> apply!(p, ExampleInSchemaV1(; in_name="greetings"))
LegolasProcessResult: Process succeeded
  ✅ record: ExampleOutSchemaV1:
 :out_name  "greetings_earthling"

julia> force_failure_example(in_record) = LegolasProcessResult(; violations=["womp", "womp"])

julia> p = LegolasProcess(ExampleInSchemaV1, ExampleOutSchemaV1, force_failure_example)
LegolasProcess (input: ExampleInSchemaV1; output: ExampleOutSchemaV1; process: force_failure_example)

julia> apply!(p, ExampleInSchemaV1(; in_name="greetings"))
LegolasProcessResult: Process failed
  ❗ womp
  ❗ womp
  ❌ record: missing
```
"""
Base.@kwdef struct LegolasProcess <: AbstractLegolasProcess
    input_schema::Type{<:Legolas.AbstractRecord}
    output_schema::Type{<:Legolas.AbstractRecord}
    apply_fn::Function  # TODO-help: how to validate the function signature (in type or on construction), to ensure takes in input schema as specified, spits out output schema?
end

#TODO-decide: do we want to enforce `input_record` type? how, if we wanted to?
"""
    apply!(process::LegolasProcess, input_record)

Return [`LegolasProcessResult`](@ref) of applying `process.apply_fn` to `input_record`.
"""
function apply!(process::LegolasProcess, input_record)
    try
        # Check that input conforms to input schema (doesn't matter if it _actually_
        # is of the same schema type, or a child, or whatever. if it conforms? it's valid.)
        # TODO-help: is there a better way to do this? e.g. to use Legolas.find_violations instead of this?
        process.input_schema(input_record)
    catch e
        return LegolasProcessResult(;
                                    violations="Record doesn't conform to input schema $(process.input_schema). Details: " *
                                               string(e))
    end
    return process.apply_fn(input_record)
end

input_schema(process::LegolasProcess) = process.input_schema
output_schema(process::LegolasProcess) = process.output_schema

function Base.show(io::IO, p::LegolasProcess)
    return print(io,
                 "LegolasProcess (input: $(p.input_schema); output: $(p.output_schema); process: $(p.apply_fn))")
end

"""
    identity_legolas_process(io_schema::Type{<:Legolas.AbstractRecord}) -> LegolasProcess{io_schema}

Create [`LegolasProcess`](@ref) where `input_schema==output_schema` and `apply_fn`
result is a `LegolasProcessResult{io_schema}`.

Required to be the first element in a [`LegolasProcessChain`](@ref).

See also: [`is_identity_process`](@ref)
"""
function identity_legolas_process(io_schema::Type{<:Legolas.AbstractRecord})
    return LegolasProcess(io_schema, io_schema, r -> LegolasProcessResult(r))
    #TODO-help: i don't really want to have to define x->..., I want to `just` use `LegolasProcessResult` instead of `x -> ...`, but the construtor for LegolasProcessResult is not recognized as conforming to the `::Function` type on contruction :(
end

"""
    is_identity_process(process::LegolasProcess) -> Bool

Check if `process` meets the definition of an [`identity_legolas_process`](@ref).
"""
function is_identity_process(process::LegolasProcess)
    if input_schema(process) != output_schema(process)
        @debug "Input and output schemas are not identical: $process"
        return false
    end
    lhs = string(code_typed(process.apply_fn, (process.input_schema,); debuginfo=:none))
    rhs = string(code_typed((r -> LegolasProcessResult(r)), (process.input_schema,);
                            debuginfo=:none))
    is_identity = isequal(lhs, rhs)
    if !is_identity
        @debug "`apply_fn` is not identity"
        @debug "Input: $lhs"
        @debug "Expected: $rhs"
    end
    return is_identity
end

#####
##### `LegolasProcessChain`
#####

"""
    LegolasProcessChain <: AbstractLegolasProcess
    LegolasProcessChain(steps::Vector{<:Tuple{Symbol,AbstractLegolasProcess, Function}})

Processing component that runs a sequence of [`AbstractLegolasProcess`](@ref) `process_steps`,
by [`apply!`](@ref)ing each step in order. The chain's `input_schema` is that of the
first element in `process_steps`; the chain's `output_schema` is that of the last
element in the `process_steps`.

The `process_steps` are stored internally as an `OrderedDict{:Symbol,AbstractLegolasProcess}`
of `<step name> => <step process>`, along with the instructions (`input_constructors`)
for constructing the input to each step as a function of all previous ouput component
results. Each key in `process_steps` has a corresponding key in `input_constructors`.
(This input construction approach/type may change in an upcoming release.)

The constructor that takes in series of `steps` expects steps to take the format
`(name, process, input_constructor)`.

To grant downstream access to all fields passed into the first step, the first step should
be an identity process, i.e., `is_identity_process(step)` should return true. Additionally,
the first step receives input directly from the overall process chain input, so
does not construct its own input; its input construction function must therefore by `nothing`.

!!! warn
    It is the caller's responsibility to only implement a DAG, and to not introduce
    recursion by constructing a chain that includes that same chain as a processing
    step! To quote Tom Lehrer, "[you ask a silly question, you get a silly answer](https://youtu.be/zWPn3esuDgU?t=189)."

## Fields

- `process_steps::OrderedDict{Symbol,AbstractLegolasProcess}` Ordered processing steps
- `input_constructors::Dict{Symbol,Function}` Dictionary with functions for constructing the input
    for each key in `process_steps` as a function that takes in a Dict{Symbol,LegolasProcessResult}
    of all upstream `process_steps` results.

## Example

TODO-future
```jldoctest
```
"""
struct LegolasProcessChain <: AbstractLegolasProcess
    process_steps::OrderedDict{Symbol,AbstractLegolasProcess}
    input_constructors::Dict{Symbol,Union{Nothing,Function}}

    function LegolasProcessChain(process_steps::OrderedDict, input_constructors::Dict)
        first_key = first(keys(process_steps))
        constructor_keys = push!(Set(collect(keys(input_constructors))), first_key)
        if !issetequal(keys(process_steps), constructor_keys)
            a = collect(setdiff(keys(process_steps), keys(input_constructors)))
            b = collect(setdiff(keys(input_constructors), keys(process_steps)))
            str = "Mismatch in chain steps:"
            isempty(a) ||
                (str *= "\n- Keys present in `process_steps` are missing in `input_constructors`: $a")
            isempty(b) ||
                (str *= "\n- Keys present in `input_constructors` are missing in `input_constructors`: $b")
            throw(ArgumentError(str))
        end
        if haskey(input_constructors, first_key) &&
           !isnothing(input_constructors[first_key])
            throw(ArgumentError("First step's input constructor must be `nothing`"))
        end
        # TODO: validate input_constructors dag!
        # TODO: other validation!
        return new(process_steps, input_constructors)
    end
end

const AbstractProcessChainStep = Tuple{Symbol,AbstractLegolasProcess,
                                       Union{Nothing,Function}}

function LegolasProcessChain(steps::Vector{<:AbstractProcessChainStep})
    process_steps = OrderedDict{Symbol,AbstractLegolasProcess}()
    input_constructors = Dict{Symbol,Union{Nothing,Function}}()
    for step in steps
        _add_step_to_chain(process_steps, input_constructors, step)
    end
    return LegolasProcessChain(process_steps, input_constructors)
end

function _add_step_to_chain(process_steps::OrderedDict{Symbol,AbstractLegolasProcess},
                            input_constructors::Dict{Symbol,Union{Nothing,Function}},
                            step::AbstractProcessChainStep)
    (key, process, input_constructor) = step
    haskey(process_steps, key) &&
        throw(ArgumentError("Key `$key` already exists in chain!"))
    push!(process_steps, key => process)
    push!(input_constructors, key => input_constructor) #TODO: first validate that these are possible...
    return nothing
end

function Base.append!(chain::LegolasProcessChain, step::AbstractProcessChainStep)
    return _add_step_to_chain(chain.process_steps, chain.input_constructors, step)
end

"""
    input_schema(chain::LegolasProcessChain) -> Type{<:Legolas.AbstractRecord}

Return Legolas schema of record accepted as input to first process in `chain.process_steps`.
"""
input_schema(c::LegolasProcessChain) = first(c.process_steps)[2].input_schema

"""
    output_schema(chain::LegolasProcessChain) -> Type{<:Legolas.AbstractRecord}

Return Legolas schema of record returned by last process in `chain.process_steps`,
which is the record returned by successful application of the entire chain.
"""
output_schema(c::LegolasProcessChain) = last(c.process_steps)[2].output_schema

"""
    apply!(chain::LegolasProcessChain, input_record)

Return [`LegolasProcessResult`](@ref) of sequentially `apply!`ing all `chain.process_steps`
to `input_record`.

Before each step (`key`), the step's `chain.input_constructors[key]` is called
on the results of all previous processing steps, in order to construct input to
the step that conforms to the step's requisite `input_schema(process)`.

Initial step does not call input construction for itself, as chain input is passed directly
into it.
"""
function apply!(chain::LegolasProcessChain, input_record)
    warnings = String[]
    component_results = OrderedDict{Symbol,Legolas.AbstractRecord}()
    for (i_process, (name, process)) in enumerate(chain.process_steps)
        @debug "Applying component `$name`..."
        input_record = if i_process == 1
            # The initial input record does not need to be constructed---it already
            # exists. (Is it valid? Who knows---but the `apply!` function will handle
            # that validation below!)
            input_record
        else
            # Construct
            input_nt = chain.input_constructors[name](component_results)

            # prob don't need this try/catch, can pass into the function as a named tuple...
            try
                process.input_schema(; input_nt...)
            catch e
                return LegolasProcessResult(; warnings,
                                            violations=["Process $name failed: $e"])
            end
        end
        result = apply!(process, input_record)

        # Compile results
        append!(warnings, result.warnings)
        isempty(result.violations) ||
            return LegolasProcessResult(; warnings, result.violations)
        component_results[name] = result.record
    end
    return LegolasProcessResult(; warnings, record=last(component_results)[2])
end

function Base.show(io::IO, c::LegolasProcessChain)
    str = "LegolasProcessChain:\n"
    for (i, (k, v)) in enumerate(c.process_steps)
        bullet = i == 1 ? "🌱" : (i == length(c.process_steps) ? "🌷" : "☀️")
        str *= "  $bullet  $k ($(v.input_schema) => $(v.output_schema))\n"
    end
    return print(io, str)
end
# TODO-future: support applying subsets of processing chain, with `init` option for passing in "upstream outputs" results
# TODO-future: figure out better way to set up input component that doesn't skip its processing
# TODO-future: define where validation happens in this chain, and how

#####
##### Shared utilities
#####

for pred in (:(==), :(isequal)),
    T in [AbstractLegolasProcess, LegolasProcessResult, LegolasProcess,
          LegolasProcessChain]

    @eval function Base.$pred(x::$T, y::$T)
        return all(p -> $pred(getproperty(x, p), getproperty(y, p)), fieldnames($T))
    end
end
# TODO-help: do we need a hash function for these as well?

#####
##### Happy little utilities
#####

_ltab_spaces(str; n::Int=2) = repeat(" ", n) * str
_mermaid_key(key) = uppercase(string(key))
_field_node_name(field, prefix, step_key) = string(_mermaid_key(step_key), prefix, field)

function _mermaid_subgraph(node_key::String, display_name::String=node_key;
                           contents::Vector{String}=String[], direction="RL")
    return ["subgraph $(node_key)[$(display_name)]",
            "  direction $direction",
            map(_ltab_spaces, contents)...,
            "end"]
end

function _mermaid_subgraph_from_chain_step(step::Pair{Symbol,LegolasProcess})
    (key, process) = step
    node_key = _mermaid_key(key)

    _schema_subgraph = (fields, prefix) -> begin
        return collect(map(fields) do field
                           return "$(_field_node_name(field, prefix, node_key))[$field]"
                       end)
    end

    inputs_subgraph = let
        prefix = "_InputSchema"
        contents = _schema_subgraph(fieldnames(input_schema(process)), prefix)
        _mermaid_subgraph(node_key * prefix, "Input schema";
                          contents, direction="RL")
    end
    outputs_subgraph = let
        prefix = "_OutputSchema"
        contents = _schema_subgraph(fieldnames(output_schema(process)), prefix)
        _mermaid_subgraph(node_key * prefix, "Output schema";
                          contents, direction="RL")
    end

    node_contents = reduce(vcat,
                           [inputs_subgraph, outputs_subgraph,
                            "$(node_key)_InputSchema == $(process.apply_fn) ==> $(node_key)_OutputSchema"])
    return _mermaid_subgraph(node_key, uppercasefirst(replace(string(key), "_" => " "));
                             contents=node_contents, direction="TB")
end

#TODO-future: it seems v likely that anything that shows up in this function
# will be shared with the validation functions
function _mermaid_links_from_chain(chain::LegolasProcessChain)

    # First, let's make a map between i/o fields
    in_fields = Dict()
    out_fields = Dict()
    for (key, process) in chain.process_steps
        in_fields[key] = NamedTuple([f => _field_node_name(f, "_InputSchema", key)
                                     for f in fieldnames(input_schema(process))])
        out_fields[key] = NamedTuple([f => _field_node_name(f, "_OutputSchema", key)
                                      for f in fieldnames(output_schema(process))])
    end

    # function Base.getproperty(str::String, sym::Symbol)
    #     @info "here"
    #     str == "config" && return string("config_", sym)
    #     return "NOPE"
    # end

    # Okay, how do we construct each input? Need to map from inputs to outputs
    # We don't want to instantiate schemas here (for one thing, we don't have
    # good mock data!) so let's make NamedTuples
    links = String[]
    for key in collect(keys(chain.process_steps))[2:end]
        @info key

        constructor = chain.input_constructors[key]
        nt_input = missing
        try
            nt_input = constructor(out_fields)
            @info nt_input
        catch e
            # @warn e
        end
        ismissing(nt_input) && continue

        for k in keys(nt_input)
            @info k
            a = string(getproperty(nt_input, k))
            b = string(in_fields[key][k])
            # @info "..." typeof(a) typeof(b)

            if contains(a, ".") || contains(b, ".")
                @warn "uh oh..." a b
                continue
            end
            push!(links, "$a --> $b")
        end
    end
    return links
end

function mermaidify_chain(chain::LegolasProcessChain; direction="TB")
    mermaid_lines = ["```mermaid", "flowchart $direction"]

    push!(mermaid_lines, "", "%% Add steps (nodes)")
    for step in chain.process_steps
        Base.append!(mermaid_lines, _mermaid_subgraph_from_chain_step(step))
    end

    push!(mermaid_lines, "", "%% Link steps (nodes)")
    # Add (hidden) links between steps to fix chain order
    keys_upper = map(_mermaid_key, collect(keys(chain.process_steps)))
    for i_key in 2:length(keys_upper)
        push!(mermaid_lines, "$(keys_upper[i_key - 1]) ~~~ $(keys_upper[i_key])")
    end

    # Create links between the various schema i/o fields
    push!(mermaid_lines, "", "%% Link step i/o fields")
    # Base.append!(mermaid_lines, _mermaid_links_from_chain(chain))
    return join(mermaid_lines, "\n") * "\n```\n"
end


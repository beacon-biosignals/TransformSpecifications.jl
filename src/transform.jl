#####
##### `TransformSpecification`
#####

"""
    TransformSpecification{T<:Type,U<:Type} <: AbstractTransformSpecification

Basic component that specifies a transform that, when applied to input of type `T`,
will return output of type `U`.

See also: [`TransformSpecification`](@ref)

## Fields

- `input_specification::T`
- `output_specification::U`
- `transform_fn::Function` Function with signature `transform_fn(::input_specification) -> output_specification`

## Example

```jldoctest test2
using Legolas: @schema, @version

@schema "example-in" ExampleInSchema
@version ExampleInSchemaV1 begin
    in_name::String
end

@schema "example-out" ExampleOutSchema
@version ExampleOutSchemaV1 begin
    out_name::String
end

function apply_example(in_record)
    out_name = in_record.in_name * " earthling"
    return ExampleOutSchemaV1(; out_name)
end
p = TransformSpecification(ExampleInSchemaV1, ExampleOutSchemaV1, apply_example)

# output
TransformSpecification{ExampleInSchemaV1,ExampleOutSchemaV1}: `apply_example`
```
```jldoctest test2
transform!(p, ExampleInSchemaV1(; in_name="greetings"))

# output
ExampleOutSchemaV1:
 :out_name  "greetings earthling"
```
"""
Base.@kwdef struct TransformSpecification{T<:Type,U<:Type} <: AbstractTransformSpecification
    input_specification::T
    output_specification::U
    transform_fn::Any
end

input_specification(ts::TransformSpecification) = ts.input_specification

output_specification(ts::TransformSpecification) = ts.output_specification

#TODO-future: could upstream a version of `Base.convert(spec::Type{<:Legolas.AbstractRecord}, input)` and use convert in place of this new function
"""
    interpret_input(::Type{T}, input::T) where {T}
    interpret_input(::Type{T}, input::T) where {T<:Legolas.AbstractRecord}
    interpret_input(spec::Type{<:Legolas.AbstractRecord}, input)
    interpret_input(spec, input)

Return `input` interpreted as type `T`: is same as `identity` function if `input`
is already of type `T`; otherwise, attempts to construct or `Base.convert`s the
the output type from the input. Will throw if conversion fails or is otherwise
undefined.

See also: [`transform!`](@ref)
"""
interpret_input(::Type{T}, input::T) where {T} = input
interpret_input(::Type{T}, input::T) where {T<:Legolas.AbstractRecord} = input
interpret_input(spec::Type{<:Legolas.AbstractRecord}, input) = (spec)(input)
interpret_input(spec, input) = convert(spec, input)

"""
    transform!(ts::TransformSpecification, input)

Return `output_specification(ts)` by applying `ts.transform_fn` to `input`.
May error if:
* `input` does not conform to `input_specification(ts)`, i.e.,
    `interpret_input(input_specification(ts), input)` errors
* `ts.transform_fn` errors when applied to the interpreted input, or
* the output generated by `ts.transform_fn` is not a `output_specification(ts)`

For a non-erroring alternative, see [`NoThrowTransform`](@ref).

See also: [`interpret_input`](@ref)
"""
function transform!(ts::TransformSpecification, input)
    # Check that input meets specification
    InSpec = input_specification(ts)
    input = try
        interpret_input(InSpec, input)
    catch
        rethrow(ArgumentError("Input doesn't conform to specification `$(InSpec)`"))
    end

    # Do transformation
    result = ts.transform_fn(input)

    # Check that output meets specification
    OutSpec = output_specification(ts)
    if !(result isa OutSpec)
        throw(ErrorException("Output doesn't conform to specification `$(OutSpec)`; is instead a `$(typeof(result))`"))
    end
    return result::OutSpec
end

function Base.show(io::IO, p::TransformSpecification)
    return print(io,
                 "TransformSpecification{$(p.input_specification),$(p.output_specification)}: `$(p.transform_fn)`")
end

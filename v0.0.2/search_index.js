var documenterSearchIndex = {"docs":
[{"location":"#TransformSpecifications.jl","page":"API Documentation","title":"TransformSpecifications.jl","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"Modules = [TransformSpecifications]\nPrivate = false","category":"page"},{"location":"#TransformSpecifications.TransformSpecifications","page":"API Documentation","title":"TransformSpecifications.TransformSpecifications","text":"TransformSpecifications\n\nThis package enables structured transform elements via defined I/O specifications.\n\n\n\n\n\n","category":"module"},{"location":"#TransformSpecifications.AbstractTransformSpecification","page":"API Documentation","title":"TransformSpecifications.AbstractTransformSpecification","text":"abstract type AbstractTransformSpecification\n\nTransform specifications are represented by subtypes of AbstractTransformSpecification. Each leaf should be immutable and define methods for\n\ninput_specification returns type expected/allowed as transform input\noutput_specification returns output type generated by successfully completed processing\ntransform!, which transforms an input of type input_specification   and returns an output of type output_specification.\n\nIt may additionally define a custom non-mutating transform function.\n\n\n\n\n\n","category":"type"},{"location":"#TransformSpecifications.DAGStep","page":"API Documentation","title":"TransformSpecifications.DAGStep","text":"DAGStep\n\nHelper struct, used to construct NoThrowDAGs. Requires fields\n\nname::String: Name of step, must be unique across a constructed DAG\ninput_assembler::TransformSpecification: Transform used to construct step's input;   see input_assembler for details.\ntransform_spec::AbstractTransformSpecification: Transform applied by step\n\n\n\n\n\n","category":"type"},{"location":"#TransformSpecifications.NoThrowDAG","page":"API Documentation","title":"TransformSpecifications.NoThrowDAG","text":"NoThrowDAG <: AbstractTransformSpecification\nNoThrowDAG(steps::AbstractVector{DAGStep})\n\nTransform specification constructed from a DAG of transform specification nodes (steps), such that calling transform! on the DAG iterates through the steps, first constructing that step's input from all preceding upstream step outputs and then appling that step's own transform to the constructed input.\n\nThe DAG's input_specification is that of the first step in the DAG; its output_specification is that of the last step. As the first step's input is by definition the same as the overall input to the DAG, its step.input_assembler must be nothing.\n\ntip: DAG construction tip\nAs the input to the DAG at is by definition the input to the first step in that DAG, only the first step will have access to the input directly passed in by the caller. To grant access to this top-level input to downstream tasks, construct the DAG with an initial step that is an identity transform, i.e., is_identity_no_throw_transform(first(steps)) returns true. Downstream steps can then depend on the output of specific fields from this initial step. The single argument TransformSpecification constructor creates such an identity transform.\n\nwarning: DAG construction warning\nIt is the caller's responsibility to implement a DAG, and to not introduce any recursion or cycles. What will happen if you do? To quote Tom Lehrer, \"well, you ask a silly question, you get a silly answer!\"\n\nwarning: Storage of intermediate values\nThe output of each step in the DAG is stored locally in memory for the entire lifetime of the transform operation, whether or not it is actually accessed by any later steps.  Large intermediate outputs may result in unexpected memory pressure relative to function composition or even local evaluation (since they are not visible to the garbage collector).\n\nFields\n\nThe following fields are constructed automatically when constructing a NoThrowDAG from a vector of DAGSteps:\n\nstep_transforms::OrderedDict{String,AbstractTransformSpecification}: Ordered dictionary of processing steps\nstep_input_assemblers::Dict{String,TransformSpecification}: Dictionary with functions for constructing the input   for each key in step_transforms as a function that takes in a Dict{String,NoThrowResult}   of all upstream step_transforms results.\n_step_output_fields::Dict{String,Dict{Symbol,Any}}: Internal mapping of upstream step   outputs to downstream inputs, used to e.g. valdiate that the input to each step   can be constructed from the outputs of the upstream steps.\n\nExample\n\nusing Legolas: @schema, @version\nusing TransformSpecifications: input_assembler\n\n@schema \"example-one-var\" ExampleOneVarSchema\n@version ExampleOneVarSchemaV1 begin\n    var::String\nend\n\n@schema \"example-two-var\" ExampleTwoVarSchema\n@version ExampleTwoVarSchemaV1 begin\n    var1::String\n    var2::String\nend\n\n# Say we have three functions we want to chain together:\nfn_a(x) = ExampleOneVarSchemaV1(; var=x.var * \"_a\")\nfn_b(x) = ExampleOneVarSchemaV1(; var=x.var * \"_b\")\nfn_c(x) = ExampleOneVarSchemaV1(; var=x.var1 * x.var2 * \"_c\")\n\n# First, specify these functions as transforms: what is the specification of the\n# function's input and output?\nstep_a_transform = NoThrowTransform(ExampleOneVarSchemaV1, ExampleOneVarSchemaV1, fn_a)\nstep_b_transform = NoThrowTransform(ExampleOneVarSchemaV1, ExampleOneVarSchemaV1, fn_b)\nstep_c_transform = NoThrowTransform(ExampleTwoVarSchemaV1, ExampleOneVarSchemaV1, fn_c)\n\n# Next, set up the DAG between the upstream outputs into each step's input:\nstep_b_assembler = input_assembler(upstream -> (; var=upstream[\"step_a\"][:var]))\nstep_c_assembler = input_assembler(upstream -> (; var1=upstream[\"step_a\"][:var],\n                                                var2=upstream[\"step_b\"][:var]))\n# ...note that step_a is skipped, as there are no steps upstream from it.\n\nsteps = [DAGStep(\"step_a\", nothing, step_a_transform),\n         DAGStep(\"step_b\", step_b_assembler, step_b_transform),\n         DAGStep(\"step_c\", step_c_assembler, step_c_transform)]\ndag = NoThrowDAG(steps)\n\n# output\nNoThrowDAG (ExampleOneVarSchemaV1 => ExampleOneVarSchemaV1):\n  üå±  step_a: ExampleOneVarSchemaV1 => ExampleOneVarSchemaV1: `fn_a`\n   ¬∑  step_b: ExampleOneVarSchemaV1 => ExampleOneVarSchemaV1: `fn_b`\n  üå∑  step_c: ExampleTwoVarSchemaV1 => ExampleOneVarSchemaV1: `fn_c`\n\nThis DAG can then be applied to an input, just like a regular TransformSpecification can:\n\ninput = ExampleOneVarSchemaV1(; var=\"initial_str\")\ntransform!(dag, input)\n\n# output\nNoThrowResult{ExampleOneVarSchemaV1}: Transform succeeded\n  ‚úÖ result: ExampleOneVarSchemaV1:\n :var  \"initial_str_ainitial_str_a_b_c\"\n\nSimilarly, this transform will fail if the input specification is violated‚Äì-but because it returns a NoThrowResult, it will fail gracefully:\n\n# What is the input specification?\ninput_specification(dag)\n\n# output\nExampleOneVarSchemaV1\n\ntransform!(dag, ExampleTwoVarSchemaV1(; var1=\"wrong\", var2=\"input schema\"))\n\n# output\nNoThrowResult{Missing}: Transform failed\n  ‚ùå Input to step `step_a` doesn't conform to specification `ExampleOneVarSchemaV1`. Details: ArgumentError(\"Invalid value set for field `var`, expected String, got a value of type Missing (missing)\")\n\n\n\n\n\n","category":"type"},{"location":"#TransformSpecifications.NoThrowResult","page":"API Documentation","title":"TransformSpecifications.NoThrowResult","text":"NoThrowResult(result::T, violations, warnings) where {T}\nNoThrowResult(result; violations=String[], warnings=String[])\nNoThrowResult(; result=missing, violations=String[], warnings=String[])\n\nType that specifies the result of a transformation, indicating successful application of a transform through presence (or lack thereof) of violations. Consists of either a non-missing result (success state) or non-empty violations and type Missing (failure state).\n\nNote that constructing a NoThrowTransform from an input result of type NoThrowTransform, e.g., NoThrowTransform(::NoThrowTransform{T}, ...), collapses down to a singleNoThrowResult{T}; any inner and outer warnings and violations fields are concatenated and returned in the resultantNoThrowResult{T}`.\n\nSee also: nothrow_succeeded\n\nFields\n\nwarnings::AbstractVector{<:AbstractString}: List of generated warnings that are not critical   enough to be violations.\nviolations::AbstractVector{<:AbstractString} List of reason(s) result was not able to be generated.\nresult::: Generated result; missing if any violations encountered.\n\nExample\n\nusing Legolas: @schema, @version\n@schema \"example\" ExampleSchemaA\n@version ExampleSchemaAV1 begin\n    name::String\nend\n\nNoThrowResult(ExampleSchemaAV1(; name=\"yeehaw\"))\n\n# output\nNoThrowResult{ExampleSchemaAV1}: Transform succeeded\n  ‚úÖ result: ExampleSchemaAV1:\n :name  \"yeehaw\"\n\nNoThrowResult(ExampleSchemaAV1(; name=\"huzzah\"); warnings=\"Hark, watch your step...\")\n\n# output\nNoThrowResult{ExampleSchemaAV1}: Transform succeeded\n  ‚ö†Ô∏è  Hark, watch your step...\n  ‚úÖ result: ExampleSchemaAV1:\n :name  \"huzzah\"\n\nNoThrowResult(; violations=[\"Epic fail!\", \"Slightly less epic fail!\"],\n                     warnings=[\"Uh oh...\"])\n\n# output\nNoThrowResult{Missing}: Transform failed\n  ‚ùå Epic fail!\n  ‚ùå Slightly less epic fail!\n  ‚ö†Ô∏è  Uh oh...\n\n\n\n\n\n","category":"type"},{"location":"#TransformSpecifications.NoThrowTransform","page":"API Documentation","title":"TransformSpecifications.NoThrowTransform","text":"NoThrowTransform{TransformSpecification{T<:Type,U<:Type}} <: AbstractTransformSpecification\n\nWrapper around a basic TransformSpecification that returns a NoThrowResult of type NoThrowResult{T}, where T is the output specification of the inner transform. If calling transform! on a NoThrowTransform errors, due to either incorrect input/output types or an exception during the transform itself, the exception will be caught and returned as a NoThrowResult{Missing}, with the error(s) in the result's violations field. See NoThrowResult for details.\n\nNote that results of a NoThrowTransform collapse down to a single NoThrowResult when nested, such that if the outputspecification of the inner TransformSpecification is itself a NoThrowResult{T}, the outputspecification of the NoThrowTransform will have that same output specification NoThrowResult{T}, and not NoThrowResult{NoThrowResult{T}}.\n\nFields\n\ntransform_spec::TransformSpecification{T,U}\n\nExample 1: Successful transformation\n\nSet-up:\n\nusing Legolas: @schema, @version\n\n@schema \"example-a\" ExampleSchemaA\n@version ExampleSchemaAV1 begin\n    in_name::String\nend\n\n@schema \"example-b\" ExampleSchemaB\n@version ExampleSchemaBV1 begin\n    out_name::String\nend\n\nfunction apply_example(in_record)\n    out_name = in_record.in_name * \" earthling\"\n    return ExampleSchemaBV1(; out_name)\nend\nntt = NoThrowTransform(ExampleSchemaAV1, ExampleSchemaBV1, apply_example)\n\n# output\nNoThrowTransform{ExampleSchemaAV1,ExampleSchemaBV1}: `apply_example`\n\nApplication of transform:\n\ntransform!(ntt, ExampleSchemaAV1(; in_name=\"greetings\"))\n\n# output\nNoThrowResult{ExampleSchemaBV1}: Transform succeeded\n  ‚úÖ result: ExampleSchemaBV1:\n :out_name  \"greetings earthling\"\n\nExample 2: Failing transformation\n\nSet-up:\n\nforce_failure_example(in_record) = NoThrowResult(; violations=[\"womp\", \"womp\"])\nntt = NoThrowTransform(ExampleSchemaAV1, ExampleSchemaBV1, force_failure_example)\n\n# output\nNoThrowTransform{ExampleSchemaAV1,ExampleSchemaBV1}: `force_failure_example`\n\nApplication of transform:\n\ntransform!(ntt, ExampleSchemaAV1(; in_name=\"greetings\"))\n\n# output\nNoThrowResult{Missing}: Transform failed\n  ‚ùå womp\n  ‚ùå womp\n\n\n\n\n\n","category":"type"},{"location":"#TransformSpecifications.NoThrowTransform-Tuple{Type}","page":"API Documentation","title":"TransformSpecifications.NoThrowTransform","text":"NoThrowTransform(specification::Type)\n\nCreate NoThrowTransform that meets the criteria of an identity NoThrowTransform, i.e., is_identity_no_throw_transform.\n\nSee also: identity_no_throw_result\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.TransformSpecification","page":"API Documentation","title":"TransformSpecifications.TransformSpecification","text":"TransformSpecification{T<:Type,U<:Type} <: AbstractTransformSpecification\n\nBasic component that specifies a transform that, when applied to input of type T, will return output of type U.\n\nSee also: TransformSpecification\n\nFields\n\ninput_specification::T\noutput_specification::U\ntransform_fn::Function Function with signature transform_fn(::input_specification) -> output_specification\n\nExample\n\nusing Legolas: @schema, @version\n\n@schema \"example-in\" ExampleInSchema\n@version ExampleInSchemaV1 begin\n    in_name::String\nend\n\n@schema \"example-out\" ExampleOutSchema\n@version ExampleOutSchemaV1 begin\n    out_name::String\nend\n\nfunction apply_example(in_record)\n    out_name = in_record.in_name * \" earthling\"\n    return ExampleOutSchemaV1(; out_name)\nend\nts = TransformSpecification(ExampleInSchemaV1, ExampleOutSchemaV1, apply_example)\n\n# output\nTransformSpecification{ExampleInSchemaV1,ExampleOutSchemaV1}: `apply_example`\n\ntransform!(ts, ExampleInSchemaV1(; in_name=\"greetings\"))\n\n# output\nExampleOutSchemaV1: (out_name = \"greetings earthling\",)\n\n\n\n\n\n","category":"type"},{"location":"#TransformSpecifications.get_step-Tuple{NoThrowDAG, String}","page":"API Documentation","title":"TransformSpecifications.get_step","text":"get_step(dag::NoThrowDAG, name::String) -> DAGStep\nget_step(dag::NoThrowDAG, step_index::Int) -> DAGStep\n\nReturn DAGStep with name or step_index.\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.input_specification","page":"API Documentation","title":"TransformSpecifications.input_specification","text":"input_specification(ts::AbstractTransformSpecification)\n\nReturn specification accepted as input to ts.\n\n\n\n\n\n","category":"function"},{"location":"#TransformSpecifications.input_specification-Tuple{NoThrowDAG}","page":"API Documentation","title":"TransformSpecifications.input_specification","text":"input_specification(dag::NoThrowDAG)\n\nReturn input_specification of first step in dag, which is the input specification of the entire DAG.\n\nSee also: output_specification, NoThrowDAG\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.is_identity_no_throw_transform-Tuple{NoThrowTransform}","page":"API Documentation","title":"TransformSpecifications.is_identity_no_throw_transform","text":"is_identity_no_throw_transform(ntt::NoThrowTransform) -> Bool\n\nCheck if ntt meets the definition of an identity NoThrowTransform, namely, output_specification(ntt) == NoThrowTransform{input_specification(ntt)} and transform function is identity_no_throw_result.\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.nothrow_succeeded-Tuple{NoThrowResult{Missing}}","page":"API Documentation","title":"TransformSpecifications.nothrow_succeeded","text":"nothrow_succeeded(result::NoThrowResult) -> Bool\n\nReturn true if result indicates successful completion, i.e. if result.violations is empty.\n\nSee also: NoThrowResult\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.output_specification","page":"API Documentation","title":"TransformSpecifications.output_specification","text":"output_specification(ts::AbstractTransformSpecification)\n\nReturn specification of return value of ts.\n\n\n\n\n\n","category":"function"},{"location":"#TransformSpecifications.output_specification-Tuple{NoThrowDAG}","page":"API Documentation","title":"TransformSpecifications.output_specification","text":"output_specification(dag::NoThrowDAG) -> Type{<:Legolas.AbstractRecord}\n\nReturn output_specification of last step in dag, which is the output specification of the entire DAG.\n\nSee also: input_specification, NoThrowDAG\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.transform!","page":"API Documentation","title":"TransformSpecifications.transform!","text":"transform!(ts::AbstractTransformSpecification, input)\n\nReturn result of applying ts to an input of type input_specification(ts), where result is an output_specification(ts). May mutate input.\n\nSee also: transform\n\n\n\n\n\n","category":"function"},{"location":"#TransformSpecifications.transform!-Tuple{NoThrowDAG, Any}","page":"API Documentation","title":"TransformSpecifications.transform!","text":"transform!(dag::NoThrowDAG, input)\n\nReturn NoThrowResult of sequentially transform!ing all dag.step_transforms, after passing input to the first step.\n\nBefore each step, that step's input_assembler is called on the results of all previous processing steps; this constructor generates input that conforms to the step's input_specification.\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.transform!-Tuple{NoThrowTransform, Any}","page":"API Documentation","title":"TransformSpecifications.transform!","text":"transform!(ntt::NoThrowTransform, input)\n\nReturn NoThrowResult of applying ntt.transform_spec.transform_fn to input. Transform will fail (i.e., return a NoThrowResult{Missing} if:\n\ninput does not conform to input_specification(ntt), i.e.,   convert_spec(input_specification(ntt), input) throws an error\nntt.transform_spec.transform_fn returns a NoThrowResult{Missing} when applied to the interpreted input,\nntt.transform_spec.transform_fn errors when applied to the interpreted input, or\nthe output generated by ntt.transform_spec.transform_fn is not a Union{NoThrowResult{Missing},output_specification(ntt)}\n\nIn any of these failure cases, this function will not throw, but instead will return the cause of failure in the output violations field.\n\nnote: Note\n\n\nFor debugging purposes, it may be helpful to bypass the \"no-throw\" feature and   so as to have access to a callstack. To do this, use transform_unwrapped!   in place of transform!.\n\nSee also: convert_spec\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.transform!-Tuple{TransformSpecification, Any}","page":"API Documentation","title":"TransformSpecifications.transform!","text":"transform!(ts::TransformSpecification, input)\n\nReturn output_specification(ts) by applying ts.transform_fn to input. May error if:\n\ninput does not conform to input_specification(ts), i.e.,   convert_spec(input_specification(ts), input) errors\nts.transform_fn errors when applied to the interpreted input, or\nthe output generated by ts.transform_fn is not a output_specification(ts)\n\nFor a non-erroring alternative, see NoThrowTransform.\n\nSee also: convert_spec\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.transform-Tuple{AbstractTransformSpecification, Any}","page":"API Documentation","title":"TransformSpecifications.transform","text":"transform(ts::AbstractTransformSpecification, input)\n\nReturn result of applying ts to an input of type input_specification(ts), where result is an output_specification(ts). May not mutate input.\n\nSee also: transform!\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.transform_unwrapped!-Tuple{NoThrowTransform, Any}","page":"API Documentation","title":"TransformSpecifications.transform_unwrapped!","text":"transform_unwrapped!(ntt::NoThrowTransform, input)\n\nApply transform! on inner ntt.transform_spec, such that the resultant output will be of type output_specification(ntt.transform_spec) rather than a NoThrowResult, any failure will result in throwing an error. Utility for debugging NoThrowTransforms.\n\nSee also: transform_unwrapped\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.transform_unwrapped-Tuple{NoThrowTransform, Any}","page":"API Documentation","title":"TransformSpecifications.transform_unwrapped","text":"transform_unwrapped(ntt::NoThrowTransform, input)\n\nNon-mutating implmementation of transform_unwrapped!; applies transform(ntt.transform_spec, input).\n\n\n\n\n\n","category":"method"},{"location":"#Non-exported-functions-and-types","page":"API Documentation","title":"Non-exported functions and types","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"Modules = [TransformSpecifications]\nPublic = false","category":"page"},{"location":"#TransformSpecifications._validate_input_assembler-Tuple{NoThrowDAG, Nothing}","page":"API Documentation","title":"TransformSpecifications._validate_input_assembler","text":"_validate_input_assembler(dag::NoThrowDAG, input_assembler::TransformSpecification)\n_validate_input_assembler(dag::NoThrowDAG, ::Nothing)\n\nConfirm that an input_assembler, when called on all upstream outputs generated by dag, has access to all fields it needs to construct its input.\n\nThis validation assumes that the dag being validated against contains only outputs from upstream steps, an assumption that will be true on DAG construction (where this validation is called from). If called at other times, validation may succeed even though the input_assembler will fail when called in situ.\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.convert_spec-Union{Tuple{T}, Tuple{Type{T}, T}} where T","page":"API Documentation","title":"TransformSpecifications.convert_spec","text":"convert_spec(::Type{T}, input::T) where {T}\nconvert_spec(::Type{T}, input::T) where {T<:Legolas.AbstractRecord}\nconvert_spec(spec::Type{<:Legolas.AbstractRecord}, input)\nconvert_spec(spec, input)\n\nReturn input interpreted as type T: is same as identity function if input is already of type T; otherwise, attempts to construct or Base.converts the the output type from the input. Will throw if conversion fails or is otherwise undefined.\n\nSee also: transform!\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.field_dict-Tuple{Type{<:NoThrowResult}}","page":"API Documentation","title":"TransformSpecifications.field_dict","text":"field_dict(type::Type{<:NoThrowResult})\nfield_dict(type)\n\nReturn a Dict where keys are fieldnames(type) and the value of each key is that field's own type. Constructed by calling field_dict_value on each input field's type.\n\nWhen type is a NoThrowResult{T}, generate mapping based on unwrapped type T.\n\nTo recurse into a specific type MyType, implement\n\nTransformSpecification.field_dict_value(t::Type{MyType}) = field_dict(t)\n\nwarning: Warning\nUse caution when implementing a field_dict_value for any type that isn't explicitly impossible to lead to recursion, as otherwise a stack overflow may occur.\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.identity_no_throw_result-Tuple{Any}","page":"API Documentation","title":"TransformSpecifications.identity_no_throw_result","text":"identity_no_throw_result(result) -> NoThrowResult\n\nReturn NoThrowResult{T} where T=typeof(result)\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.input_assembler-Tuple{Any}","page":"API Documentation","title":"TransformSpecifications.input_assembler","text":"input_assembler(conversion_fn) -> TransformSpecification{Dict{String,Any}, NamedTuple}\n\nSpecial transform used to convert the outputs of upstream steps in a NoThrowDAG into a NamedTuple that can be converted into that type's input specification.\n\nconversion_fn must be a function that\n\ntakes as input a Dictionary with keys that are the names of upstream steps, where   the value of each of these keys is the output of that upstreamstep, as   specified by `outputspecification(upstream_step)`.\nreturns a NamedTuple that can be converted, via convert_spec, to the   specification of an AbstractTransformSpecification that it is paired with   in a DAGStep.\n\nNote that the current implementation is a stopgap for a better-defined implementation defined in https://github.com/beacon-biosignals/TransformSpecifications.jl/issues/8\n\n\n\n\n\n","category":"method"},{"location":"#TransformSpecifications.is_input_assembler-Tuple{AbstractTransformSpecification}","page":"API Documentation","title":"TransformSpecifications.is_input_assembler","text":"is_input_assembler(ts::AbstractTransformSpecification) -> Bool\n\nConfirm that ts is an input_assembler.\n\n\n\n\n\n","category":"method"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TransformSpecifications.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TransformSpecifications.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Introduction-and-Overview"><span>Introduction &amp; Overview</span></a></li><li><a class="tocitem" href="#Table-of-contents"><span>Table of contents</span></a></li><li><a class="tocitem" href="#TransformSpecification"><span><code>TransformSpecification</code></span></a></li><li><a class="tocitem" href="#NoThrowTransform"><span><code>NoThrowTransform</code></span></a></li><li><a class="tocitem" href="#NoThrowDAG"><span><code>NoThrowDAG</code></span></a></li><li><a class="tocitem" href="#Plotting-NoThrowDAGs"><span>Plotting <code>NoThrowDAG</code>s</span></a></li><li><a class="tocitem" href="#TransformSpecifications-interface"><span>TransformSpecifications interface</span></a></li></ul></li><li><a class="tocitem" href="api/">API Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><script type="module">
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({ startOnLoad: true });
</script><h1 id="TransformSpecifications.jl"><a class="docs-heading-anchor" href="#TransformSpecifications.jl">TransformSpecifications.jl</a><a id="TransformSpecifications.jl-1"></a><a class="docs-heading-anchor-permalink" href="#TransformSpecifications.jl" title="Permalink"></a></h1><p>Enabling structured transformations via defined I/O specifications.</p><h2 id="Introduction-and-Overview"><a class="docs-heading-anchor" href="#Introduction-and-Overview">Introduction &amp; Overview</a><a id="Introduction-and-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-and-Overview" title="Permalink"></a></h2><p>This package provides tools to define explicitly-specified transformation components. Such components can then be used to define pipelines that are themselves composed of individual explicitly-specified components, or facilitate distributed computation.  One primary use-case is in creating explicitly defined pipelines that chain components together. These pipelines are in the form of <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graphs (DAGs)</a>, where each node of the graph is a component, and the edges correspond to data transfers between the components. The graph is &quot;directed&quot; since data flows in one direction (from the outputs of a component to the inputs of another), and &quot;acyclic&quot; since cycles are not allowed; one component cannot supply data to another which then supplies data back to the original component.</p><p>Later in the documentation, we will get into a lot more details about the tools that this package provides. But first, let us look at the high-level steps one follows to define such a pipeline using this package.</p><ol><li>Define the inputs and outputs of each step. TransformSpecifications itself does not provide (nor require) specific types for defining inputs and outputs, but this is commonly implemented via <a href="https://github.com/beacon-biosignals/Legolas.jl">Legolas.jl</a> schemas.</li><li>Define functions that takes each set inputs to the corresponding outputs. For the purposes of setting up the pipeline, these can be placeholder functions that don&#39;t actually do anything, but once you want to run the pipeline, these will need to do whatever work is required in order to generate the outputs from the inputs. Again, this step is independent of any code in TransformSpecifications.jl itself.</li><li>Package up steps (1) and (2) into <a href="#TransformSpecifications.AbstractTransformSpecification"><code>AbstractTransformSpecification</code></a>s, like <a href="#TransformSpecifications.TransformSpecification"><code>TransformSpecification</code></a> and <a href="#TransformSpecifications.NoThrowTransform"><code>NoThrowTransform</code></a>. These are the &quot;components&quot;, the nodes of the graph.</li><li>Create <a href="#TransformSpecifications.input_assembler-Tuple{Any}"><code>input_assembler</code></a>s for each component to route necessary outputs of previous components into the inputs of the component. This creates the edges of the graph.</li><li>Create a DAG using <a href="#TransformSpecifications.DAGStep"><code>DAGStep</code></a> or <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a> to assemble all of the components and assemblers into a DAG.</li><li>Use it! Apply the DAG to inputs using <a href="#TransformSpecifications.transform!"><code>transform!</code></a> or <a href="#TransformSpecifications.transform"><code>transform</code></a>, and create a mermaid diagram using <a href="#TransformSpecifications.mermaidify-Tuple{NoThrowDAG}"><code>mermaidify</code></a>.</li></ol><p>With these general steps in mind, it can help to see some examples.</p><ul><li>For example of all of these steps together, see <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a>.</li><li>For a basic concrete transform, see <a href="#TransformSpecifications.TransformSpecification"><code>TransformSpecification</code></a></li><li>For transforms that catch exceptions and return them as formatted violations, see <a href="#TransformSpecifications.NoThrowTransform"><code>NoThrowTransform</code></a> (and <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a>).</li><li>For the abstract interface, see <a href="#TransformSpecifications-interface">TransformSpecifications interface</a></li><li>For a compound transform that is itself a concrete <code>AbstractTransformSpecification</code> and is constructed from a DAG of <code>AbstractTransformSpecification</code>s, see <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a><ul><li>For a plotted graph visualization of such a DAG, see <a href="#Plotting-NoThrowDAGs">Plotting <code>NoThrowDAG</code>s</a>.</li></ul></li></ul><h2 id="Table-of-contents"><a class="docs-heading-anchor" href="#Table-of-contents">Table of contents</a><a id="Table-of-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-contents" title="Permalink"></a></h2><ul><li><a href="#TransformSpecifications.jl">TransformSpecifications.jl</a></li><li class="no-marker"><ul><li><a href="#Introduction-and-Overview">Introduction &amp; Overview</a></li><li><a href="#Table-of-contents">Table of contents</a></li><li><a href="#TransformSpecification"><code>TransformSpecification</code></a></li><li><a href="#NoThrowTransform"><code>NoThrowTransform</code></a></li><li><a href="#NoThrowDAG"><code>NoThrowDAG</code></a></li><li><a href="#Plotting-NoThrowDAGs">Plotting <code>NoThrowDAG</code>s</a></li><li><a href="#TransformSpecifications-interface">TransformSpecifications interface</a></li><li class="no-marker"><ul><li><a href="#Required-interface-type">Required interface type</a></li><li><a href="#Required-interface-methods">Required interface methods</a></li><li><a href="#Other-interface-methods">Other interface methods</a></li></ul></li></ul></li><li><a href="api/#API">API</a></li><li class="no-marker"><ul><li><a href="api/#Exported-functions-and-types">Exported functions and types</a></li><li><a href="api/#Non-exported-functions-and-types">Non-exported functions and types</a></li></ul></li></ul><h2 id="TransformSpecification"><a class="docs-heading-anchor" href="#TransformSpecification"><code>TransformSpecification</code></a><a id="TransformSpecification-1"></a><a class="docs-heading-anchor-permalink" href="#TransformSpecification" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.TransformSpecification" href="#TransformSpecifications.TransformSpecification"><code>TransformSpecifications.TransformSpecification</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransformSpecification{T&lt;:Type,U&lt;:Type} &lt;: AbstractTransformSpecification</code></pre><p>Basic component that specifies a transform that, when applied to input of type <code>T</code>, will return output of type <code>U</code>.</p><p>See also: <a href="#TransformSpecifications.TransformSpecification"><code>TransformSpecification</code></a></p><p><strong>Fields</strong></p><ul><li><code>input_specification::T</code></li><li><code>output_specification::U</code></li><li><code>transform_fn::Function</code> Function with signature <code>transform_fn(::input_specification) -&gt; output_specification</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Legolas: @schema, @version

@schema &quot;example-in&quot; ExampleInSchema
@version ExampleInSchemaV1 begin
    in_name::String
end

@schema &quot;example-out&quot; ExampleOutSchema
@version ExampleOutSchemaV1 begin
    out_name::String
end

function apply_example(in_record)
    out_name = in_record.in_name * &quot; earthling&quot;
    return ExampleOutSchemaV1(; out_name)
end
ts = TransformSpecification(ExampleInSchemaV1, ExampleOutSchemaV1, apply_example)

# output
TransformSpecification{ExampleInSchemaV1,ExampleOutSchemaV1}: `apply_example`</code></pre><pre><code class="language-julia hljs">transform!(ts, ExampleInSchemaV1(; in_name=&quot;greetings&quot;))

# output
ExampleOutSchemaV1: (out_name = &quot;greetings earthling&quot;,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/transform.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform!-Tuple{TransformSpecification, Any}" href="#TransformSpecifications.transform!-Tuple{TransformSpecification, Any}"><code>TransformSpecifications.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(ts::TransformSpecification, input)</code></pre><p>Return <code>output_specification(ts)</code> by applying <code>ts.transform_fn</code> to <code>input</code>. May error if:</p><ul><li><code>input</code> does not conform to <code>input_specification(ts)</code>, i.e.,   <code>convert_spec(input_specification(ts), input)</code> errors</li><li><code>ts.transform_fn</code> errors when applied to the interpreted input, or</li><li>the output generated by <code>ts.transform_fn</code> is not a <code>output_specification(ts)</code></li></ul><p>For a non-erroring alternative, see <a href="#TransformSpecifications.NoThrowTransform"><code>NoThrowTransform</code></a>.</p><p>See also: <a href="api/#TransformSpecifications.convert_spec-Union{Tuple{T}, Tuple{Type{T}, T}} where T"><code>convert_spec</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/transform.jl#L75-L88">source</a></section></article><h2 id="NoThrowTransform"><a class="docs-heading-anchor" href="#NoThrowTransform"><code>NoThrowTransform</code></a><a id="NoThrowTransform-1"></a><a class="docs-heading-anchor-permalink" href="#NoThrowTransform" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.NoThrowResult" href="#TransformSpecifications.NoThrowResult"><code>TransformSpecifications.NoThrowResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoThrowResult(result::T, violations, warnings) where {T}
NoThrowResult(result; violations=String[], warnings=String[])
NoThrowResult(; result=missing, violations=String[], warnings=String[])</code></pre><p>Type that specifies the result of a transformation, indicating successful application of a transform through presence (or lack thereof) of <code>violations</code>. Consists of either a non-<code>missing</code> <code>result</code> (success state) or non-empty <code>violations</code> and type <code>Missing</code> (failure state).</p><p>Note that constructing a <code>NoThrowTransform</code> from an input <code>result</code> of type <code>NoThrowTransform</code>, e.g., <code>NoThrowTransform(::NoThrowTransform{T}, ...), collapses down to a single</code>NoThrowResult{T}<code>; any inner and outer warnings and violations fields are concatenated and returned in the resultant</code>NoThrowResult{T}`.</p><p>See also: <a href="#TransformSpecifications.nothrow_succeeded-Tuple{NoThrowResult{Missing}}"><code>nothrow_succeeded</code></a></p><p><strong>Fields</strong></p><ul><li><code>warnings::AbstractVector{&lt;:AbstractString}</code>: List of generated warnings that are not critical   enough to be <code>violations</code>.</li><li><code>violations::AbstractVector{&lt;:AbstractString}</code> List of reason(s) <code>result</code> was not able to be generated.</li><li><code>result::</code>: Generated <code>result</code>; <code>missing</code> if any <code>violations</code> encountered.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Legolas: @schema, @version
@schema &quot;example&quot; ExampleSchemaA
@version ExampleSchemaAV1 begin
    name::String
end

NoThrowResult(ExampleSchemaAV1(; name=&quot;yeehaw&quot;))

# output
NoThrowResult{ExampleSchemaAV1}: Transform succeeded
  ✅ result: ExampleSchemaAV1:
 :name  &quot;yeehaw&quot;</code></pre><pre><code class="language-julia hljs">NoThrowResult(ExampleSchemaAV1(; name=&quot;huzzah&quot;); warnings=&quot;Hark, watch your step...&quot;)

# output
NoThrowResult{ExampleSchemaAV1}: Transform succeeded
  ⚠️  Hark, watch your step...
  ✅ result: ExampleSchemaAV1:
 :name  &quot;huzzah&quot;</code></pre><pre><code class="language-julia hljs">NoThrowResult(; violations=[&quot;Epic fail!&quot;, &quot;Slightly less epic fail!&quot;],
                     warnings=[&quot;Uh oh...&quot;])

# output
NoThrowResult{Missing}: Transform failed
  ❌ Epic fail!
  ❌ Slightly less epic fail!
  ⚠️  Uh oh...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow.jl#L5-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.NoThrowTransform" href="#TransformSpecifications.NoThrowTransform"><code>TransformSpecifications.NoThrowTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoThrowTransform{TransformSpecification{T&lt;:Type,U&lt;:Type}} &lt;: AbstractTransformSpecification</code></pre><p>Wrapper around a basic <a href="#TransformSpecifications.TransformSpecification"><code>TransformSpecification</code></a> that returns a <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a> of type <code>NoThrowResult{T}</code>, where <code>T</code> is the output specification of the inner transform. If calling <code>transform!</code> on a <code>NoThrowTransform</code> errors, due to either incorrect input/output types or an exception during the transform itself, the exception will be caught and returned as a <code>NoThrowResult{Missing}</code>, with the error(s) in the result&#39;s <code>violations</code> field. See <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a> for details.</p><p>Note that results of a <code>NoThrowTransform</code> collapse down to a single <code>NoThrowResult</code> when nested, such that if the output<em>specification of the inner TransformSpecification is itself a <code>NoThrowResult{T}</code>, the output</em>specification of the <code>NoThrowTransform</code> will have that same output specification <code>NoThrowResult{T}</code>, and <em>not</em> <code>NoThrowResult{NoThrowResult{T}}</code>.</p><p><strong>Fields</strong></p><ul><li><code>transform_spec::TransformSpecification{T,U}</code></li></ul><p><strong>Example 1: Successful transformation</strong></p><p>Set-up:</p><pre><code class="language-julia hljs">using Legolas: @schema, @version

@schema &quot;example-a&quot; ExampleSchemaA
@version ExampleSchemaAV1 begin
    in_name::String
end

@schema &quot;example-b&quot; ExampleSchemaB
@version ExampleSchemaBV1 begin
    out_name::String
end

function apply_example(in_record)
    out_name = in_record.in_name * &quot; earthling&quot;
    return ExampleSchemaBV1(; out_name)
end
ntt = NoThrowTransform(ExampleSchemaAV1, ExampleSchemaBV1, apply_example)

# output
NoThrowTransform{ExampleSchemaAV1,ExampleSchemaBV1}: `apply_example`</code></pre><p>Application of transform:</p><pre><code class="language-julia hljs">transform!(ntt, ExampleSchemaAV1(; in_name=&quot;greetings&quot;))

# output
NoThrowResult{ExampleSchemaBV1}: Transform succeeded
  ✅ result: ExampleSchemaBV1:
 :out_name  &quot;greetings earthling&quot;</code></pre><p><strong>Example 2: Failing transformation</strong></p><p>Set-up:</p><pre><code class="language-julia hljs">force_failure_example(in_record) = NoThrowResult(; violations=[&quot;womp&quot;, &quot;womp&quot;])
ntt = NoThrowTransform(ExampleSchemaAV1, ExampleSchemaBV1, force_failure_example)

# output
NoThrowTransform{ExampleSchemaAV1,ExampleSchemaBV1}: `force_failure_example`</code></pre><p>Application of transform:</p><pre><code class="language-julia hljs">transform!(ntt, ExampleSchemaAV1(; in_name=&quot;greetings&quot;))

# output
NoThrowResult{Missing}: Transform failed
  ❌ womp
  ❌ womp</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow.jl#L136-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.NoThrowTransform-Tuple{Type}" href="#TransformSpecifications.NoThrowTransform-Tuple{Type}"><code>TransformSpecifications.NoThrowTransform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NoThrowTransform(specification::Type)</code></pre><p>Create <a href="#TransformSpecifications.NoThrowTransform"><code>NoThrowTransform</code></a> that meets the criteria of an identity NoThrowTransform, i.e., <a href="#TransformSpecifications.is_identity_no_throw_transform-Tuple{NoThrowTransform}"><code>is_identity_no_throw_transform</code></a>.</p><p>See also: <a href="api/#TransformSpecifications.identity_no_throw_result-Tuple{Any}"><code>identity_no_throw_result</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow.jl#L219-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.is_identity_no_throw_transform-Tuple{NoThrowTransform}" href="#TransformSpecifications.is_identity_no_throw_transform-Tuple{NoThrowTransform}"><code>TransformSpecifications.is_identity_no_throw_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_identity_no_throw_transform(ntt::NoThrowTransform) -&gt; Bool</code></pre><p>Check if <code>ntt</code> meets the definition of an identity NoThrowTransform, namely, <code>output_specification(ntt) == NoThrowTransform{input_specification(ntt)}</code> and transform function is <a href="api/#TransformSpecifications.identity_no_throw_result-Tuple{Any}"><code>identity_no_throw_result</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow.jl#L322-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.nothrow_succeeded-Tuple{NoThrowResult{Missing}}" href="#TransformSpecifications.nothrow_succeeded-Tuple{NoThrowResult{Missing}}"><code>TransformSpecifications.nothrow_succeeded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nothrow_succeeded(result::NoThrowResult) -&gt; Bool</code></pre><p>Return <code>true</code> if <code>result</code> indicates successful completion, i.e. if <code>result.violations</code> is empty.</p><p>See also: <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform!-Tuple{NoThrowTransform, Any}" href="#TransformSpecifications.transform!-Tuple{NoThrowTransform, Any}"><code>TransformSpecifications.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(ntt::NoThrowTransform, input)</code></pre><p>Return <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a> of applying <code>ntt.transform_spec.transform_fn</code> to <code>input</code>. Transform will fail (i.e., return a <code>NoThrowResult{Missing}</code> if:</p><ul><li><code>input</code> does not conform to <code>input_specification(ntt)</code>, i.e.,   <code>convert_spec(input_specification(ntt), input)</code> throws an error</li><li><code>ntt.transform_spec.transform_fn</code> returns a <code>NoThrowResult{Missing}</code> when applied to the interpreted input,</li><li><code>ntt.transform_spec.transform_fn</code> errors when applied to the interpreted input, or</li><li>the output generated by <code>ntt.transform_spec.transform_fn</code> is not a <code>Union{NoThrowResult{Missing},output_specification(ntt)}</code></li></ul><p>In any of these failure cases, this function will not throw, but instead will return the cause of failure in the output <code>violations</code> field.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>For debugging purposes, it may be helpful to bypass the &quot;no-throw&quot; feature and   so as to have access to a callstack. To do this, use <a href="#TransformSpecifications.transform_unwrapped!-Tuple{NoThrowTransform, Any}"><code>transform_unwrapped!</code></a>   in place of <code>transform!</code>.</p><p>See also: <a href="api/#TransformSpecifications.convert_spec-Union{Tuple{T}, Tuple{Type{T}, T}} where T"><code>convert_spec</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow.jl#L238-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform_unwrapped!-Tuple{NoThrowTransform, Any}" href="#TransformSpecifications.transform_unwrapped!-Tuple{NoThrowTransform, Any}"><code>TransformSpecifications.transform_unwrapped!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform_unwrapped!(ntt::NoThrowTransform, input)</code></pre><p>Apply <a href="#TransformSpecifications.transform!"><code>transform!</code></a> on inner <code>ntt.transform_spec</code>, such that the resultant output will be of type <code>output_specification(ntt.transform_spec)</code> rather than a <code>NoThrowResult</code>, any failure <em>will</em> result in throwing an error. Utility for debugging <code>NoThrowTransform</code>s.</p><p>See also: <a href="#TransformSpecifications.transform_unwrapped-Tuple{NoThrowTransform, Any}"><code>transform_unwrapped</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow.jl#L295-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform_unwrapped-Tuple{NoThrowTransform, Any}" href="#TransformSpecifications.transform_unwrapped-Tuple{NoThrowTransform, Any}"><code>TransformSpecifications.transform_unwrapped</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform_unwrapped(ntt::NoThrowTransform, input)</code></pre><p>Non-mutating implmementation of <a href="#TransformSpecifications.transform_unwrapped!-Tuple{NoThrowTransform, Any}"><code>transform_unwrapped!</code></a>; applies <code>transform(ntt.transform_spec, input)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow.jl#L307-L312">source</a></section></article><h2 id="NoThrowDAG"><a class="docs-heading-anchor" href="#NoThrowDAG"><code>NoThrowDAG</code></a><a id="NoThrowDAG-1"></a><a class="docs-heading-anchor-permalink" href="#NoThrowDAG" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.DAGStep" href="#TransformSpecifications.DAGStep"><code>TransformSpecifications.DAGStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DAGStep</code></pre><p>Helper struct, used to construct <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a>s. Requires fields</p><ul><li><code>name::String</code>: Name of step, must be unique across a constructed DAG</li><li><code>input_assembler::TransformSpecification</code>: Transform used to construct step&#39;s input;   see <a href="#TransformSpecifications.input_assembler-Tuple{Any}"><code>input_assembler</code></a> for details.</li><li><code>transform_spec::AbstractTransformSpecification</code>: Transform applied by step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow_dag.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.NoThrowDAG" href="#TransformSpecifications.NoThrowDAG"><code>TransformSpecifications.NoThrowDAG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoThrowDAG &lt;: AbstractTransformSpecification
NoThrowDAG(steps::AbstractVector{DAGStep})</code></pre><p>Transform specification constructed from a DAG of transform specification nodes (<code>steps</code>), such that calling <a href="#TransformSpecifications.transform!"><code>transform!</code></a> on the DAG iterates through the steps, first constructing that step&#39;s input from all preceding upstream step outputs and then appling that step&#39;s own transform to the constructed input.</p><p>The DAG&#39;s <code>input_specification</code> is that of the first step in the DAG; its <code>output_specification</code> is that of the last step. As the first step&#39;s input is by definition the same as the overall input to the DAG, its <code>step.input_assembler</code> must be <code>nothing</code>.</p><div class="admonition is-success"><header class="admonition-header">DAG construction tip</header><div class="admonition-body"><p>As the input to the DAG at is by definition the input to the first step in that DAG, only the first step will have access to the input directly passed in by the caller. To grant access to this top-level input to downstream tasks, construct the DAG with an initial step that is an identity transform, i.e., <code>is_identity_no_throw_transform(first(steps))</code> returns true. Downstream steps can then depend on the output of specific fields from this initial step. The single argument <a href="#TransformSpecifications.TransformSpecification"><code>TransformSpecification</code></a> constructor creates such an identity transform.</p></div></div><div class="admonition is-warning"><header class="admonition-header">DAG construction warning</header><div class="admonition-body"><p>It is the caller&#39;s responsibility to implement a DAG, and to not introduce any recursion or cycles. What will happen if you do? To quote Tom Lehrer, &quot;<a href="https://youtu.be/zWPn3esuDgU?t=189">well, you ask a silly question, you get a silly answer</a>!&quot;</p></div></div><div class="admonition is-warning"><header class="admonition-header">Storage of intermediate values</header><div class="admonition-body"><p>The output of each step in the DAG is stored locally in memory for the entire lifetime of the <code>transform</code> operation, whether or not it is actually accessed by any later steps.  Large intermediate outputs may result in unexpected memory pressure relative to function composition or even local evaluation (since they are not visible to the garbage collector).</p></div></div><p><strong>Fields</strong></p><p>The following fields are constructed automatically when constructing a <code>NoThrowDAG</code> from a vector of <code>DAGSteps</code>:</p><ul><li><code>step_transforms::OrderedDict{String,AbstractTransformSpecification}</code>: Ordered dictionary of processing steps</li><li><code>step_input_assemblers::Dict{String,TransformSpecification}</code>: Dictionary with functions for constructing the input   for each key in <code>step_transforms</code> as a function that takes in a Dict{String,NoThrowResult}   of all upstream <code>step_transforms</code> results.</li><li><code>_step_output_fields::Dict{String,Dict{Symbol,Any}}</code>: Internal mapping of upstream step   outputs to downstream inputs, used to e.g. valdiate that the input to each step   can be constructed from the outputs of the upstream steps.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Legolas: @schema, @version

@schema &quot;example-one-var&quot; ExampleOneVarSchema
@version ExampleOneVarSchemaV1 begin
    var::String
end

@schema &quot;example-two-var&quot; ExampleTwoVarSchema
@version ExampleTwoVarSchemaV1 begin
    var1::String
    var2::String
end

# Say we have three functions we want to chain together:
fn_a(x) = ExampleOneVarSchemaV1(; var=x.var * &quot;_a&quot;)
fn_b(x) = ExampleOneVarSchemaV1(; var=x.var * &quot;_b&quot;)
fn_c(x) = ExampleOneVarSchemaV1(; var=x.var1 * x.var2 * &quot;_c&quot;)

# First, specify these functions as transforms: what is the specification of the
# function&#39;s input and output?
step_a_transform = NoThrowTransform(ExampleOneVarSchemaV1, ExampleOneVarSchemaV1, fn_a)
step_b_transform = NoThrowTransform(ExampleOneVarSchemaV1, ExampleOneVarSchemaV1, fn_b)
step_c_transform = NoThrowTransform(ExampleTwoVarSchemaV1, ExampleOneVarSchemaV1, fn_c)

# Next, set up the DAG between the upstream outputs into each step&#39;s input:
step_b_assembler = input_assembler(upstream -&gt; (; var=upstream[&quot;step_a&quot;][:var]))
step_c_assembler = input_assembler(upstream -&gt; (; var1=upstream[&quot;step_a&quot;][:var],
                                                var2=upstream[&quot;step_b&quot;][:var]))
# ...note that step_a is skipped, as there are no steps upstream from it.

steps = [DAGStep(&quot;step_a&quot;, nothing, step_a_transform),
         DAGStep(&quot;step_b&quot;, step_b_assembler, step_b_transform),
         DAGStep(&quot;step_c&quot;, step_c_assembler, step_c_transform)]
dag = NoThrowDAG(steps)

# output
NoThrowDAG (ExampleOneVarSchemaV1 =&gt; ExampleOneVarSchemaV1):
  🌱  step_a: ExampleOneVarSchemaV1 =&gt; ExampleOneVarSchemaV1: `fn_a`
   ·  step_b: ExampleOneVarSchemaV1 =&gt; ExampleOneVarSchemaV1: `fn_b`
  🌷  step_c: ExampleTwoVarSchemaV1 =&gt; ExampleOneVarSchemaV1: `fn_c`</code></pre><p>This DAG can then be applied to an input, just like a regular <code>TransformSpecification</code> can:</p><pre><code class="language-julia hljs">input = ExampleOneVarSchemaV1(; var=&quot;initial_str&quot;)
transform!(dag, input)

# output
NoThrowResult{ExampleOneVarSchemaV1}: Transform succeeded
  ✅ result: ExampleOneVarSchemaV1:
 :var  &quot;initial_str_ainitial_str_a_b_c&quot;</code></pre><p>Similarly, this transform will fail if the input specification is violated–-but because it returns a <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a>, it will fail gracefully:</p><pre><code class="language-julia hljs"># What is the input specification?
input_specification(dag)

# output
ExampleOneVarSchemaV1</code></pre><pre><code class="language-julia hljs">transform!(dag, ExampleTwoVarSchemaV1(; var1=&quot;wrong&quot;, var2=&quot;input schema&quot;))

# output
NoThrowResult{Missing}: Transform failed
  ❌ Input to step `step_a` doesn&#39;t conform to specification `ExampleOneVarSchemaV1`. Details: ArgumentError(&quot;Invalid value set for field `var`, expected String, got a value of type Missing (missing)&quot;)</code></pre><p>To visualize this DAG, you may want to generate a plot via <a href="https://mermaid.js.org/">mermaid</a>, which is a markdown-like plotting language that is rendered automatically via GitHub and various other platforms. To create a mermaid plot of a DAG, use <a href="#TransformSpecifications.mermaidify-Tuple{NoThrowDAG}"><code>mermaidify</code></a>:</p><pre><code class="language-julia hljs">mermaid_str = mermaidify(dag)

# No need to dump full output string here, but let&#39;s check that the results are
# the same as in our generated ouptut test, so that we know that the rendered graph
# in the documentation stays synced with the code.
print(mermaid_str)

# output
flowchart

%% Define steps (nodes)
subgraph OUTERLEVEL[&quot;` `&quot;]
direction LR
subgraph STEP_A[Step a]
  direction TB
  subgraph STEP_A_InputSchema[Input: ExampleOneVarSchemaV1]
    direction RL
    STEP_A_InputSchemavar{{&quot;var::String&quot;}}
    class STEP_A_InputSchemavar classSpecField
  end
  subgraph STEP_A_OutputSchema[Output: ExampleOneVarSchemaV1]
    direction RL
    STEP_A_OutputSchemavar{{&quot;var::String&quot;}}
    class STEP_A_OutputSchemavar classSpecField
  end
  STEP_A_InputSchema:::classSpec -- fn_a --&gt; STEP_A_OutputSchema:::classSpec
end
subgraph STEP_B[Step b]
  direction TB
  subgraph STEP_B_InputSchema[Input: ExampleOneVarSchemaV1]
    direction RL
    STEP_B_InputSchemavar{{&quot;var::String&quot;}}
    class STEP_B_InputSchemavar classSpecField
  end
  subgraph STEP_B_OutputSchema[Output: ExampleOneVarSchemaV1]
    direction RL
    STEP_B_OutputSchemavar{{&quot;var::String&quot;}}
    class STEP_B_OutputSchemavar classSpecField
  end
  STEP_B_InputSchema:::classSpec -- fn_b --&gt; STEP_B_OutputSchema:::classSpec
end
subgraph STEP_C[Step c]
  direction TB
  subgraph STEP_C_InputSchema[Input: ExampleTwoVarSchemaV1]
    direction RL
    STEP_C_InputSchemavar1{{&quot;var1::String&quot;}}
    class STEP_C_InputSchemavar1 classSpecField
    STEP_C_InputSchemavar2{{&quot;var2::String&quot;}}
    class STEP_C_InputSchemavar2 classSpecField
  end
  subgraph STEP_C_OutputSchema[Output: ExampleOneVarSchemaV1]
    direction RL
    STEP_C_OutputSchemavar{{&quot;var::String&quot;}}
    class STEP_C_OutputSchemavar classSpecField
  end
  STEP_C_InputSchema:::classSpec -- fn_c --&gt; STEP_C_OutputSchema:::classSpec
end

%% Link steps (edges)
STEP_A:::classStep -..-&gt; STEP_B:::classStep
STEP_B:::classStep -..-&gt; STEP_C:::classStep

end
OUTERLEVEL:::classOuter ~~~ OUTERLEVEL:::classOuter

%% Styling definitions
classDef classOuter fill:#cbd7e2,stroke:#000,stroke-width:0px;
classDef classStep fill:#eeedff,stroke:#000,stroke-width:2px;
classDef classSpec fill:#f8f7ff,stroke:#000,stroke-width:1px;
classDef classSpecField fill:#fff,stroke:#000,stroke-width:1px;</code></pre><p>See this rendered plot in the <a href="https://beacon-biosignals.github.io/TransformSpecifications.jl/dev">built documentation</a>.</p><p>To display a mermaid plot via e.g. Documenter.jl, <a href="https://github.com/JuliaDocs/Documenter.jl/issues/1943">additional setup will be required</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow_dag.jl#L129-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.get_step-Tuple{NoThrowDAG, String}" href="#TransformSpecifications.get_step-Tuple{NoThrowDAG, String}"><code>TransformSpecifications.get_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_step(dag::NoThrowDAG, name::String) -&gt; DAGStep
get_step(dag::NoThrowDAG, step_index::Int) -&gt; DAGStep</code></pre><p>Return <code>DAGStep</code> with <code>name</code> or <code>step_index</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow_dag.jl#L371-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.input_assembler-Tuple{Any}" href="#TransformSpecifications.input_assembler-Tuple{Any}"><code>TransformSpecifications.input_assembler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input_assembler(conversion_fn) -&gt; TransformSpecification{Dict{String,Any}, NamedTuple}</code></pre><p>Special transform used to convert the outputs of upstream steps in a <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a> into a <code>NamedTuple</code> that can be converted into that type&#39;s input specification.</p><p><code>conversion_fn</code> must be a function that</p><ul><li>takes as input a Dictionary with keys that are the names of upstream steps, where   the value of each of these keys is the output of that upstream<em>step, as   specified by `output</em>specification(upstream_step)`.</li><li>returns a <code>NamedTuple</code> that can be converted, via <a href="api/#TransformSpecifications.convert_spec-Union{Tuple{T}, Tuple{Type{T}, T}} where T"><code>convert_spec</code></a>, to the   specification of an <code>AbstractTransformSpecification</code> that it is paired with   in a <a href="#TransformSpecifications.DAGStep"><code>DAGStep</code></a>.</li></ul><p>Note that the current implementation is a stopgap for a better-defined implementation defined in https://github.com/beacon-biosignals/TransformSpecifications.jl/issues/8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow_dag.jl#L27-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.input_specification-Tuple{NoThrowDAG}" href="#TransformSpecifications.input_specification-Tuple{NoThrowDAG}"><code>TransformSpecifications.input_specification</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input_specification(dag::NoThrowDAG)</code></pre><p>Return <code>input_specification</code> of first step in <code>dag</code>, which is the input specification of the entire DAG.</p><p>See also: <a href="#TransformSpecifications.output_specification"><code>output_specification</code></a>, <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow_dag.jl#L385-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.output_specification-Tuple{NoThrowDAG}" href="#TransformSpecifications.output_specification-Tuple{NoThrowDAG}"><code>TransformSpecifications.output_specification</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">output_specification(dag::NoThrowDAG) -&gt; Type{&lt;:Legolas.AbstractRecord}</code></pre><p>Return output_specification of last step in <code>dag</code>, which is the output specification of the entire DAG.</p><p>See also: <a href="#TransformSpecifications.input_specification"><code>input_specification</code></a>, <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow_dag.jl#L397-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform!-Tuple{NoThrowDAG, Any}" href="#TransformSpecifications.transform!-Tuple{NoThrowDAG, Any}"><code>TransformSpecifications.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(dag::NoThrowDAG, input)</code></pre><p>Return <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a> of sequentially <a href="#TransformSpecifications.transform!"><code>transform!</code></a>ing all <code>dag.step_transforms</code>, after passing <code>input</code> to the first step.</p><p>Before each step, that step&#39;s <code>input_assembler</code> is called on the results of all previous processing steps; this constructor generates input that conforms to the step&#39;s <code>input_specification</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/nothrow_dag.jl#L409-L418">source</a></section></article><p>Here is the mermaid plot generated for the example DAG in <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a>:</p><h2 id="Plotting-NoThrowDAGs"><a class="docs-heading-anchor" href="#Plotting-NoThrowDAGs">Plotting <code>NoThrowDAG</code>s</a><a id="Plotting-NoThrowDAGs-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-NoThrowDAGs" title="Permalink"></a></h2><div class="mermaid">
flowchart

%% Define steps (nodes)
subgraph OUTERLEVEL["` `"]
direction LR
subgraph STEP_A[Step a]
  direction TB
  subgraph STEP_A_InputSchema[Input: ExampleOneVarSchemaV1]
    direction RL
    STEP_A_InputSchemavar{{"var::String"}}
    class STEP_A_InputSchemavar classSpecField
  end
  subgraph STEP_A_OutputSchema[Output: ExampleOneVarSchemaV1]
    direction RL
    STEP_A_OutputSchemavar{{"var::String"}}
    class STEP_A_OutputSchemavar classSpecField
  end
  STEP_A_InputSchema:::classSpec -- fn_a --> STEP_A_OutputSchema:::classSpec
end
subgraph STEP_B[Step b]
  direction TB
  subgraph STEP_B_InputSchema[Input: ExampleOneVarSchemaV1]
    direction RL
    STEP_B_InputSchemavar{{"var::String"}}
    class STEP_B_InputSchemavar classSpecField
  end
  subgraph STEP_B_OutputSchema[Output: ExampleOneVarSchemaV1]
    direction RL
    STEP_B_OutputSchemavar{{"var::String"}}
    class STEP_B_OutputSchemavar classSpecField
  end
  STEP_B_InputSchema:::classSpec -- fn_b --> STEP_B_OutputSchema:::classSpec
end
subgraph STEP_C[Step c]
  direction TB
  subgraph STEP_C_InputSchema[Input: ExampleTwoVarSchemaV1]
    direction RL
    STEP_C_InputSchemavar1{{"var1::String"}}
    class STEP_C_InputSchemavar1 classSpecField
    STEP_C_InputSchemavar2{{"var2::String"}}
    class STEP_C_InputSchemavar2 classSpecField
  end
  subgraph STEP_C_OutputSchema[Output: ExampleOneVarSchemaV1]
    direction RL
    STEP_C_OutputSchemavar{{"var::String"}}
    class STEP_C_OutputSchemavar classSpecField
  end
  STEP_C_InputSchema:::classSpec -- fn_c --> STEP_C_OutputSchema:::classSpec
end

%% Link steps (edges)
STEP_A:::classStep -..-> STEP_B:::classStep
STEP_B:::classStep -..-> STEP_C:::classStep

end
OUTERLEVEL:::classOuter ~~~ OUTERLEVEL:::classOuter

%% Styling definitions
classDef classOuter fill:#cbd7e2,stroke:#000,stroke-width:0px;
classDef classStep fill:#eeedff,stroke:#000,stroke-width:2px;
classDef classSpec fill:#f8f7ff,stroke:#000,stroke-width:1px;
classDef classSpecField fill:#fff,stroke:#000,stroke-width:1px;
</div><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.mermaidify-Tuple{NoThrowDAG}" href="#TransformSpecifications.mermaidify-Tuple{NoThrowDAG}"><code>TransformSpecifications.mermaidify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mermaidify(dag::NoThrowDAG; direction=&quot;LR&quot;,
           style_step=&quot;fill:#eeedff,stroke:#000,stroke-width:2px;&quot;,
           style_spec=&quot;fill:#f8f7ff,stroke:#000,stroke-width:1px;&quot;,
           style_outer=&quot;fill:#cbd7e2,stroke:#000,stroke-width:0px;&quot;,
           style_spec_field=&quot;fill:#fff,stroke:#000,stroke-width:1px;&quot;)</code></pre><p>Generate <a href="https://mermaid.js.org/">mermaid plot</a> of <code>dag</code>, suitable for inclusion in markdown documentation.</p><p>Args:</p><ul><li><code>direction</code>: option that specifies the orientation/flow of the dag&#39;s steps;   most useful options for dag plotting are <code>LR</code> (left to right) or <code>TB</code> (top to bottom);   see the mermaid documentation for full list of options.</li><li><code>style_step</code>: styling of the box containing an individual dag step (node)</li><li><code>style_spec</code>: styling of the boxes containing the input and output specifications for each step</li><li><code>style_outer</code>: styling of the box bounding the entire DAG</li><li><code>style_spec_field</code>: styling of the boxes bounding each specification&#39;s individual field(s)</li></ul><p>For each style kwarg, see the mermaid documentation for style string options.</p><p>To include in markdown, do</p><pre><code class="language-markdown hljs">```mermaid
{{mermaidify output}}
```</code></pre><p>or for html (i.e., for Documenter.jl), do</p><pre><code class="language-markdown hljs">&lt;div class=&quot;mermaid&quot;&gt;
{{mermaidify output}}
&lt;/div&gt;</code></pre><p>For an example of the raw output, see <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a>; for an example of the rendered output, see <a href="https://beacon-biosignals.github.io/TransformSpecifications.jl/dev">the built documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/mermaid.jl#L16-L51">source</a></section></article><h2 id="TransformSpecifications-interface"><a class="docs-heading-anchor" href="#TransformSpecifications-interface">TransformSpecifications interface</a><a id="TransformSpecifications-interface-1"></a><a class="docs-heading-anchor-permalink" href="#TransformSpecifications-interface" title="Permalink"></a></h2><p>TransformSpecifications provides a general interface which allows the creation of new subtypes of <code>AbstractTransformSpecification</code> that can be used to implement transformation.</p><p>New transformation types <em>must</em> subtype <code>AbstractTransformSpecification</code>, and implement the following required methods.</p><h3 id="Required-interface-type"><a class="docs-heading-anchor" href="#Required-interface-type">Required interface type</a><a id="Required-interface-type-1"></a><a class="docs-heading-anchor-permalink" href="#Required-interface-type" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.AbstractTransformSpecification" href="#TransformSpecifications.AbstractTransformSpecification"><code>TransformSpecifications.AbstractTransformSpecification</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractTransformSpecification</code></pre><p>Transform specifications are represented by subtypes of <code>AbstractTransformSpecification</code>. Each leaf should be immutable and define methods for</p><ul><li><a href="#TransformSpecifications.input_specification"><code>input_specification</code></a> returns type expected/allowed as transform input</li><li><a href="#TransformSpecifications.output_specification"><code>output_specification</code></a> returns output type generated by successfully completed processing</li><li><a href="#TransformSpecifications.transform!"><code>transform!</code></a>, which transforms an input of type <code>input_specification</code>   and returns an output of type <code>output_specification</code>.</li></ul><p>It may additionally define a custom non-mutating <a href="#TransformSpecifications.transform"><code>transform</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/abstract.jl#L5-L16">source</a></section></article><h3 id="Required-interface-methods"><a class="docs-heading-anchor" href="#Required-interface-methods">Required interface methods</a><a id="Required-interface-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Required-interface-methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform!" href="#TransformSpecifications.transform!"><code>TransformSpecifications.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform!(ts::AbstractTransformSpecification, input)</code></pre><p>Return result of applying <code>ts</code> to an <code>input</code> of type <code>input_specification(ts)</code>, where result is an <code>output_specification(ts)</code>. May mutate <code>input</code>.</p><p>See also: <a href="#TransformSpecifications.transform"><code>transform</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/abstract.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.input_specification" href="#TransformSpecifications.input_specification"><code>TransformSpecifications.input_specification</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">input_specification(ts::AbstractTransformSpecification)</code></pre><p>Return specification accepted as input to <code>ts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/abstract.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.output_specification" href="#TransformSpecifications.output_specification"><code>TransformSpecifications.output_specification</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">output_specification(ts::AbstractTransformSpecification)</code></pre><p>Return specification of return value of <code>ts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/abstract.jl#L46-L50">source</a></section></article><h3 id="Other-interface-methods"><a class="docs-heading-anchor" href="#Other-interface-methods">Other interface methods</a><a id="Other-interface-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Other-interface-methods" title="Permalink"></a></h3><p>These methods have reasonable fallback definitions and should only be defined for new types if there is some reason to prefer a custom implementation over the default fallback.</p><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform" href="#TransformSpecifications.transform"><code>TransformSpecifications.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform(ts::AbstractTransformSpecification, input)</code></pre><p>Return result of applying <code>ts</code> to an <code>input</code> of type <code>input_specification(ts)</code>, where result is an <code>output_specification(ts)</code>. May not mutate <code>input</code>.</p><p>See also: <a href="#TransformSpecifications.transform!"><code>transform!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/1584d1b56fe0976149cccbd78c645a5d95e5ee9f/src/abstract.jl#L29-L36">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API Documentation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 22 August 2023 15:39">Tuesday 22 August 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · TransformSpecifications.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TransformSpecifications.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Non-exported-functions-and-types"><span>Non-exported functions and types</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TransformSpecifications.jl"><a class="docs-heading-anchor" href="#TransformSpecifications.jl">TransformSpecifications.jl</a><a id="TransformSpecifications.jl-1"></a><a class="docs-heading-anchor-permalink" href="#TransformSpecifications.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.TransformSpecifications" href="#TransformSpecifications.TransformSpecifications"><code>TransformSpecifications.TransformSpecifications</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">TransformSpecifications</code></pre><p>This package enables structured transform elements via defined I/O specifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/TransformSpecifications.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.AbstractTransformSpecification" href="#TransformSpecifications.AbstractTransformSpecification"><code>TransformSpecifications.AbstractTransformSpecification</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractTransformSpecification</code></pre><p>Transform specifications are represented by subtypes of <code>AbstractTransformSpecification</code>. Each leaf should be immutable and define methods for</p><ul><li><a href="#TransformSpecifications.input_specification"><code>input_specification</code></a> returns type expected/allowed as transform input</li><li><a href="#TransformSpecifications.output_specification"><code>output_specification</code></a> returns output type generated by successfully completed processing</li><li><a href="#TransformSpecifications.transform!"><code>transform!</code></a>, which transforms an input of type <code>input_specification</code>   and returns an output of type <code>output_specification</code>.</li></ul><p>It may additionally define a custom non-mutating <a href="#TransformSpecifications.transform-Tuple{AbstractTransformSpecification, Any}"><code>transform</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/abstract.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.DAGStep" href="#TransformSpecifications.DAGStep"><code>TransformSpecifications.DAGStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DAGStep</code></pre><p>Helper struct, used to construct <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a>s. Requires fields</p><ul><li><code>name::String</code>: Name of step, must be unique across a constructed DAG</li><li><code>input_assembler::TransformSpecification</code>: Transform used to construct step&#39;s input;   see <a href="#TransformSpecifications.input_assembler-Tuple{Any}"><code>input_assembler</code></a> for details.</li><li><code>transform_spec::AbstractTransformSpecification</code>: Transform applied by step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow_dag.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.NoThrowDAG" href="#TransformSpecifications.NoThrowDAG"><code>TransformSpecifications.NoThrowDAG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoThrowDAG &lt;: AbstractTransformSpecification
NoThrowDAG(steps::AbstractVector{DAGStep})</code></pre><p>Transform specification constructed from a DAG of transform specification nodes (<code>steps</code>), such that calling <a href="#TransformSpecifications.transform!"><code>transform!</code></a> on the DAG iterates through the steps, first constructing that step&#39;s input from all preceding upstream step outputs and then appling that step&#39;s own transform to the constructed input.</p><p>The DAG&#39;s <code>input_specification</code> is that of the first step in the DAG; its <code>output_specification</code> is that of the last step. As the first step&#39;s input is by definition the same as the overall input to the DAG, its <code>step.input_assembler</code> must be <code>nothing</code>.</p><div class="admonition is-success"><header class="admonition-header">DAG construction tip</header><div class="admonition-body"><p>As the input to the DAG at is by definition the input to the first step in that DAG, only the first step will have access to the input directly passed in by the caller. To grant access to this top-level input to downstream tasks, construct the DAG with an initial step that is an identity transform, i.e., <code>is_identity_no_throw_transform(first(steps))</code> returns true. Downstream steps can then depend on the output of specific fields from this initial step. The single argument <a href="#TransformSpecifications.TransformSpecification"><code>TransformSpecification</code></a> constructor creates such an identity transform.</p></div></div><div class="admonition is-warning"><header class="admonition-header">DAG construction warning</header><div class="admonition-body"><p>It is the caller&#39;s responsibility to implement a DAG, and to not introduce any recursion or cycles. What will happen if you do? To quote Tom Lehrer, &quot;<a href="https://youtu.be/zWPn3esuDgU?t=189">well, you ask a silly question, you get a silly answer</a>!&quot;</p></div></div><div class="admonition is-warning"><header class="admonition-header">Storage of intermediate values</header><div class="admonition-body"><p>The output of each step in the DAG is stored locally in memory for the entire lifetime of the <code>transform</code> operation, whether or not it is actually accessed by any later steps.  Large intermediate outputs may result in unexpected memory pressure relative to function composition or even local evaluation (since they are not visible to the garbage collector).</p></div></div><p><strong>Fields</strong></p><p>The following fields are constructed automatically when constructing a <code>NoThrowDAG</code> from a vector of <code>DAGSteps</code>:</p><ul><li><code>step_transforms::OrderedDict{String,AbstractTransformSpecification}</code>: Ordered dictionary of processing steps</li><li><code>step_input_assemblers::Dict{String,TransformSpecification}</code>: Dictionary with functions for constructing the input   for each key in <code>step_transforms</code> as a function that takes in a Dict{String,NoThrowResult}   of all upstream <code>step_transforms</code> results.</li><li><code>_step_output_fields::Dict{String,Dict{Symbol,Any}}</code>: Internal mapping of upstream step   outputs to downstream inputs, used to e.g. valdiate that the input to each step   can be constructed from the outputs of the upstream steps.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Legolas: @schema, @version
using TransformSpecifications: input_assembler

@schema &quot;example-one-var&quot; ExampleOneVarSchema
@version ExampleOneVarSchemaV1 begin
    var::String
end

@schema &quot;example-two-var&quot; ExampleTwoVarSchema
@version ExampleTwoVarSchemaV1 begin
    var1::String
    var2::String
end

# Say we have three functions we want to chain together:
fn_a(x) = ExampleOneVarSchemaV1(; var=x.var * &quot;_a&quot;)
fn_b(x) = ExampleOneVarSchemaV1(; var=x.var * &quot;_b&quot;)
fn_c(x) = ExampleOneVarSchemaV1(; var=x.var1 * x.var2 * &quot;_c&quot;)

# First, specify these functions as transforms: what is the specification of the
# function&#39;s input and output?
step_a_transform = NoThrowTransform(ExampleOneVarSchemaV1, ExampleOneVarSchemaV1, fn_a)
step_b_transform = NoThrowTransform(ExampleOneVarSchemaV1, ExampleOneVarSchemaV1, fn_b)
step_c_transform = NoThrowTransform(ExampleTwoVarSchemaV1, ExampleOneVarSchemaV1, fn_c)

# Next, set up the DAG between the upstream outputs into each step&#39;s input:
step_b_assembler = input_assembler(upstream -&gt; (; var=upstream[&quot;step_a&quot;][:var]))
step_c_assembler = input_assembler(upstream -&gt; (; var1=upstream[&quot;step_a&quot;][:var],
                                                var2=upstream[&quot;step_b&quot;][:var]))
# ...note that step_a is skipped, as there are no steps upstream from it.

steps = [DAGStep(&quot;step_a&quot;, nothing, step_a_transform),
         DAGStep(&quot;step_b&quot;, step_b_assembler, step_b_transform),
         DAGStep(&quot;step_c&quot;, step_c_assembler, step_c_transform)]
dag = NoThrowDAG(steps)

# output
NoThrowDAG (ExampleOneVarSchemaV1 =&gt; ExampleOneVarSchemaV1):
  🌱  step_a: ExampleOneVarSchemaV1 =&gt; ExampleOneVarSchemaV1: `fn_a`
   ·  step_b: ExampleOneVarSchemaV1 =&gt; ExampleOneVarSchemaV1: `fn_b`
  🌷  step_c: ExampleTwoVarSchemaV1 =&gt; ExampleOneVarSchemaV1: `fn_c`</code></pre><p>This DAG can then be applied to an input, just like a regular <code>TransformSpecification</code> can:</p><pre><code class="language-julia hljs">input = ExampleOneVarSchemaV1(; var=&quot;initial_str&quot;)
transform!(dag, input)

# output
NoThrowResult{ExampleOneVarSchemaV1}: Transform succeeded
  ✅ result: ExampleOneVarSchemaV1:
 :var  &quot;initial_str_ainitial_str_a_b_c&quot;</code></pre><p>Similarly, this transform will fail if the input specification is violated–-but because it returns a <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a>, it will fail gracefully:</p><pre><code class="language-julia hljs"># What is the input specification?
input_specification(dag)

# output
ExampleOneVarSchemaV1</code></pre><pre><code class="language-julia hljs">transform!(dag, ExampleTwoVarSchemaV1(; var1=&quot;wrong&quot;, var2=&quot;input schema&quot;))

# output
NoThrowResult{Missing}: Transform failed
  ❌ Input to step `step_a` doesn&#39;t conform to specification `ExampleOneVarSchemaV1`. Details: ArgumentError(&quot;Invalid value set for field `var`, expected String, got a value of type Missing (missing)&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow_dag.jl#L64-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.NoThrowResult" href="#TransformSpecifications.NoThrowResult"><code>TransformSpecifications.NoThrowResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoThrowResult(result::T, violations, warnings) where {T}
NoThrowResult(result; violations=String[], warnings=String[])
NoThrowResult(; result=missing, violations=String[], warnings=String[])</code></pre><p>Type that specifies the result of a transformation, indicating successful application of a transform through presence (or lack thereof) of <code>violations</code>. Consists of either a non-<code>missing</code> <code>result</code> (success state) or non-empty <code>violations</code> and type <code>Missing</code> (failure state).</p><p>Note that constructing a <code>NoThrowTransform</code> from an input <code>result</code> of type <code>NoThrowTransform</code>, e.g., <code>NoThrowTransform(::NoThrowTransform{T}, ...), collapses down to a single</code>NoThrowResult{T}<code>; any inner and outer warnings and violations fields are concatenated and returned in the resultant</code>NoThrowResult{T}`.</p><p>See also: <a href="#TransformSpecifications.nothrow_succeeded-Tuple{NoThrowResult{Missing}}"><code>nothrow_succeeded</code></a></p><p><strong>Fields</strong></p><ul><li><code>warnings::AbstractVector{&lt;:AbstractString}</code>: List of generated warnings that are not critical   enough to be <code>violations</code>.</li><li><code>violations::AbstractVector{&lt;:AbstractString}</code> List of reason(s) <code>result</code> was not able to be generated.</li><li><code>result::</code>: Generated <code>result</code>; <code>missing</code> if any <code>violations</code> encountered.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Legolas: @schema, @version
@schema &quot;example&quot; ExampleSchemaA
@version ExampleSchemaAV1 begin
    name::String
end

NoThrowResult(ExampleSchemaAV1(; name=&quot;yeehaw&quot;))

# output
NoThrowResult{ExampleSchemaAV1}: Transform succeeded
  ✅ result: ExampleSchemaAV1:
 :name  &quot;yeehaw&quot;</code></pre><pre><code class="language-julia hljs">NoThrowResult(ExampleSchemaAV1(; name=&quot;huzzah&quot;); warnings=&quot;Hark, watch your step...&quot;)

# output
NoThrowResult{ExampleSchemaAV1}: Transform succeeded
  ⚠️  Hark, watch your step...
  ✅ result: ExampleSchemaAV1:
 :name  &quot;huzzah&quot;</code></pre><pre><code class="language-julia hljs">NoThrowResult(; violations=[&quot;Epic fail!&quot;, &quot;Slightly less epic fail!&quot;],
                     warnings=[&quot;Uh oh...&quot;])

# output
NoThrowResult{Missing}: Transform failed
  ❌ Epic fail!
  ❌ Slightly less epic fail!
  ⚠️  Uh oh...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow.jl#L5-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.NoThrowTransform" href="#TransformSpecifications.NoThrowTransform"><code>TransformSpecifications.NoThrowTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoThrowTransform{TransformSpecification{T&lt;:Type,U&lt;:Type}} &lt;: AbstractTransformSpecification</code></pre><p>Wrapper around a basic <a href="#TransformSpecifications.TransformSpecification"><code>TransformSpecification</code></a> that returns a <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a> of type <code>NoThrowResult{T}</code>, where <code>T</code> is the output specification of the inner transform. If calling <code>transform!</code> on a <code>NoThrowTransform</code> errors, due to either incorrect input/output types or an exception during the transform itself, the exception will be caught and returned as a <code>NoThrowResult{Missing}</code>, with the error(s) in the result&#39;s <code>violations</code> field. See <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a> for details.</p><p>Note that results of a <code>NoThrowTransform</code> collapse down to a single <code>NoThrowResult</code> when nested, such that if the output<em>specification of the inner TransformSpecification is itself a <code>NoThrowResult{T}</code>, the output</em>specification of the <code>NoThrowTransform</code> will have that same output specification <code>NoThrowResult{T}</code>, and <em>not</em> <code>NoThrowResult{NoThrowResult{T}}</code>.</p><p><strong>Fields</strong></p><ul><li><code>transform_spec::TransformSpecification{T,U}</code></li></ul><p><strong>Example 1: Successful transformation</strong></p><p>Set-up:</p><pre><code class="language-julia hljs">using Legolas: @schema, @version

@schema &quot;example-a&quot; ExampleSchemaA
@version ExampleSchemaAV1 begin
    in_name::String
end

@schema &quot;example-b&quot; ExampleSchemaB
@version ExampleSchemaBV1 begin
    out_name::String
end

function apply_example(in_record)
    out_name = in_record.in_name * &quot; earthling&quot;
    return ExampleSchemaBV1(; out_name)
end
ntt = NoThrowTransform(ExampleSchemaAV1, ExampleSchemaBV1, apply_example)

# output
NoThrowTransform{ExampleSchemaAV1,ExampleSchemaBV1}: `apply_example`</code></pre><p>Application of transform:</p><pre><code class="language-julia hljs">transform!(ntt, ExampleSchemaAV1(; in_name=&quot;greetings&quot;))

# output
NoThrowResult{ExampleSchemaBV1}: Transform succeeded
  ✅ result: ExampleSchemaBV1:
 :out_name  &quot;greetings earthling&quot;</code></pre><p><strong>Example 2: Failing transformation</strong></p><p>Set-up:</p><pre><code class="language-julia hljs">force_failure_example(in_record) = NoThrowResult(; violations=[&quot;womp&quot;, &quot;womp&quot;])
ntt = NoThrowTransform(ExampleSchemaAV1, ExampleSchemaBV1, force_failure_example)

# output
NoThrowTransform{ExampleSchemaAV1,ExampleSchemaBV1}: `force_failure_example`</code></pre><p>Application of transform:</p><pre><code class="language-julia hljs">transform!(ntt, ExampleSchemaAV1(; in_name=&quot;greetings&quot;))

# output
NoThrowResult{Missing}: Transform failed
  ❌ womp
  ❌ womp</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow.jl#L136-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.NoThrowTransform-Tuple{Type}" href="#TransformSpecifications.NoThrowTransform-Tuple{Type}"><code>TransformSpecifications.NoThrowTransform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NoThrowTransform(specification::Type)</code></pre><p>Create <a href="#TransformSpecifications.NoThrowTransform"><code>NoThrowTransform</code></a> that meets the criteria of an identity NoThrowTransform, i.e., <a href="#TransformSpecifications.is_identity_no_throw_transform-Tuple{NoThrowTransform}"><code>is_identity_no_throw_transform</code></a>.</p><p>See also: <a href="#TransformSpecifications.identity_no_throw_result-Tuple{Any}"><code>identity_no_throw_result</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow.jl#L219-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.TransformSpecification" href="#TransformSpecifications.TransformSpecification"><code>TransformSpecifications.TransformSpecification</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransformSpecification{T&lt;:Type,U&lt;:Type} &lt;: AbstractTransformSpecification</code></pre><p>Basic component that specifies a transform that, when applied to input of type <code>T</code>, will return output of type <code>U</code>.</p><p>See also: <a href="#TransformSpecifications.TransformSpecification"><code>TransformSpecification</code></a></p><p><strong>Fields</strong></p><ul><li><code>input_specification::T</code></li><li><code>output_specification::U</code></li><li><code>transform_fn::Function</code> Function with signature <code>transform_fn(::input_specification) -&gt; output_specification</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Legolas: @schema, @version

@schema &quot;example-in&quot; ExampleInSchema
@version ExampleInSchemaV1 begin
    in_name::String
end

@schema &quot;example-out&quot; ExampleOutSchema
@version ExampleOutSchemaV1 begin
    out_name::String
end

function apply_example(in_record)
    out_name = in_record.in_name * &quot; earthling&quot;
    return ExampleOutSchemaV1(; out_name)
end
ts = TransformSpecification(ExampleInSchemaV1, ExampleOutSchemaV1, apply_example)

# output
TransformSpecification{ExampleInSchemaV1,ExampleOutSchemaV1}: `apply_example`</code></pre><pre><code class="language-julia hljs">transform!(ts, ExampleInSchemaV1(; in_name=&quot;greetings&quot;))

# output
ExampleOutSchemaV1: (out_name = &quot;greetings earthling&quot;,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/transform.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.get_step-Tuple{NoThrowDAG, String}" href="#TransformSpecifications.get_step-Tuple{NoThrowDAG, String}"><code>TransformSpecifications.get_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_step(dag::NoThrowDAG, name::String) -&gt; DAGStep
get_step(dag::NoThrowDAG, step_index::Int) -&gt; DAGStep</code></pre><p>Return <code>DAGStep</code> with <code>name</code> or <code>step_index</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow_dag.jl#L275-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.input_specification" href="#TransformSpecifications.input_specification"><code>TransformSpecifications.input_specification</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">input_specification(ts::AbstractTransformSpecification)</code></pre><p>Return specification accepted as input to <code>ts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/abstract.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.input_specification-Tuple{NoThrowDAG}" href="#TransformSpecifications.input_specification-Tuple{NoThrowDAG}"><code>TransformSpecifications.input_specification</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input_specification(dag::NoThrowDAG)</code></pre><p>Return <code>input_specification</code> of first step in <code>dag</code>, which is the input specification of the entire DAG.</p><p>See also: <a href="#TransformSpecifications.output_specification"><code>output_specification</code></a>, <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow_dag.jl#L289-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.is_identity_no_throw_transform-Tuple{NoThrowTransform}" href="#TransformSpecifications.is_identity_no_throw_transform-Tuple{NoThrowTransform}"><code>TransformSpecifications.is_identity_no_throw_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_identity_no_throw_transform(ntt::NoThrowTransform) -&gt; Bool</code></pre><p>Check if <code>ntt</code> meets the definition of an identity NoThrowTransform, namely, <code>output_specification(ntt) == NoThrowTransform{input_specification(ntt)}</code> and transform function is <a href="#TransformSpecifications.identity_no_throw_result-Tuple{Any}"><code>identity_no_throw_result</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow.jl#L322-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.nothrow_succeeded-Tuple{NoThrowResult{Missing}}" href="#TransformSpecifications.nothrow_succeeded-Tuple{NoThrowResult{Missing}}"><code>TransformSpecifications.nothrow_succeeded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nothrow_succeeded(result::NoThrowResult) -&gt; Bool</code></pre><p>Return <code>true</code> if <code>result</code> indicates successful completion, i.e. if <code>result.violations</code> is empty.</p><p>See also: <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.output_specification" href="#TransformSpecifications.output_specification"><code>TransformSpecifications.output_specification</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">output_specification(ts::AbstractTransformSpecification)</code></pre><p>Return specification of return value of <code>ts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/abstract.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.output_specification-Tuple{NoThrowDAG}" href="#TransformSpecifications.output_specification-Tuple{NoThrowDAG}"><code>TransformSpecifications.output_specification</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">output_specification(dag::NoThrowDAG) -&gt; Type{&lt;:Legolas.AbstractRecord}</code></pre><p>Return output_specification of last step in <code>dag</code>, which is the output specification of the entire DAG.</p><p>See also: <a href="#TransformSpecifications.input_specification"><code>input_specification</code></a>, <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow_dag.jl#L301-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform!" href="#TransformSpecifications.transform!"><code>TransformSpecifications.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform!(ts::AbstractTransformSpecification, input)</code></pre><p>Return result of applying <code>ts</code> to an <code>input</code> of type <code>input_specification(ts)</code>, where result is an <code>output_specification(ts)</code>. May mutate <code>input</code>.</p><p>See also: <a href="#TransformSpecifications.transform-Tuple{AbstractTransformSpecification, Any}"><code>transform</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/abstract.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform!-Tuple{NoThrowDAG, Any}" href="#TransformSpecifications.transform!-Tuple{NoThrowDAG, Any}"><code>TransformSpecifications.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(dag::NoThrowDAG, input)</code></pre><p>Return <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a> of sequentially <a href="#TransformSpecifications.transform!"><code>transform!</code></a>ing all <code>dag.step_transforms</code>, after passing <code>input</code> to the first step.</p><p>Before each step, that step&#39;s <code>input_assembler</code> is called on the results of all previous processing steps; this constructor generates input that conforms to the step&#39;s <code>input_specification</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow_dag.jl#L313-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform!-Tuple{NoThrowTransform, Any}" href="#TransformSpecifications.transform!-Tuple{NoThrowTransform, Any}"><code>TransformSpecifications.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(ntt::NoThrowTransform, input)</code></pre><p>Return <a href="#TransformSpecifications.NoThrowResult"><code>NoThrowResult</code></a> of applying <code>ntt.transform_spec.transform_fn</code> to <code>input</code>. Transform will fail (i.e., return a <code>NoThrowResult{Missing}</code> if:</p><ul><li><code>input</code> does not conform to <code>input_specification(ntt)</code>, i.e.,   <code>convert_spec(input_specification(ntt), input)</code> throws an error</li><li><code>ntt.transform_spec.transform_fn</code> returns a <code>NoThrowResult{Missing}</code> when applied to the interpreted input,</li><li><code>ntt.transform_spec.transform_fn</code> errors when applied to the interpreted input, or</li><li>the output generated by <code>ntt.transform_spec.transform_fn</code> is not a <code>Union{NoThrowResult{Missing},output_specification(ntt)}</code></li></ul><p>In any of these failure cases, this function will not throw, but instead will return the cause of failure in the output <code>violations</code> field.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>For debugging purposes, it may be helpful to bypass the &quot;no-throw&quot; feature and   so as to have access to a callstack. To do this, use <a href="#TransformSpecifications.transform_unwrapped!-Tuple{NoThrowTransform, Any}"><code>transform_unwrapped!</code></a>   in place of <code>transform!</code>.</p><p>See also: <a href="#TransformSpecifications.convert_spec-Union{Tuple{T}, Tuple{Type{T}, T}} where T"><code>convert_spec</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow.jl#L238-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform!-Tuple{TransformSpecification, Any}" href="#TransformSpecifications.transform!-Tuple{TransformSpecification, Any}"><code>TransformSpecifications.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(ts::TransformSpecification, input)</code></pre><p>Return <code>output_specification(ts)</code> by applying <code>ts.transform_fn</code> to <code>input</code>. May error if:</p><ul><li><code>input</code> does not conform to <code>input_specification(ts)</code>, i.e.,   <code>convert_spec(input_specification(ts), input)</code> errors</li><li><code>ts.transform_fn</code> errors when applied to the interpreted input, or</li><li>the output generated by <code>ts.transform_fn</code> is not a <code>output_specification(ts)</code></li></ul><p>For a non-erroring alternative, see <a href="#TransformSpecifications.NoThrowTransform"><code>NoThrowTransform</code></a>.</p><p>See also: <a href="#TransformSpecifications.convert_spec-Union{Tuple{T}, Tuple{Type{T}, T}} where T"><code>convert_spec</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/transform.jl#L75-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform-Tuple{AbstractTransformSpecification, Any}" href="#TransformSpecifications.transform-Tuple{AbstractTransformSpecification, Any}"><code>TransformSpecifications.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(ts::AbstractTransformSpecification, input)</code></pre><p>Return result of applying <code>ts</code> to an <code>input</code> of type <code>input_specification(ts)</code>, where result is an <code>output_specification(ts)</code>. May not mutate <code>input</code>.</p><p>See also: <a href="#TransformSpecifications.transform!"><code>transform!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/abstract.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform_unwrapped!-Tuple{NoThrowTransform, Any}" href="#TransformSpecifications.transform_unwrapped!-Tuple{NoThrowTransform, Any}"><code>TransformSpecifications.transform_unwrapped!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform_unwrapped!(ntt::NoThrowTransform, input)</code></pre><p>Apply <a href="#TransformSpecifications.transform!"><code>transform!</code></a> on inner <code>ntt.transform_spec</code>, such that the resultant output will be of type <code>output_specification(ntt.transform_spec)</code> rather than a <code>NoThrowResult</code>, any failure <em>will</em> result in throwing an error. Utility for debugging <code>NoThrowTransform</code>s.</p><p>See also: <a href="#TransformSpecifications.transform_unwrapped-Tuple{NoThrowTransform, Any}"><code>transform_unwrapped</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow.jl#L295-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.transform_unwrapped-Tuple{NoThrowTransform, Any}" href="#TransformSpecifications.transform_unwrapped-Tuple{NoThrowTransform, Any}"><code>TransformSpecifications.transform_unwrapped</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform_unwrapped(ntt::NoThrowTransform, input)</code></pre><p>Non-mutating implmementation of <a href="#TransformSpecifications.transform_unwrapped!-Tuple{NoThrowTransform, Any}"><code>transform_unwrapped!</code></a>; applies <code>transform(ntt.transform_spec, input)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow.jl#L307-L312">source</a></section></article><h2 id="Non-exported-functions-and-types"><a class="docs-heading-anchor" href="#Non-exported-functions-and-types">Non-exported functions and types</a><a id="Non-exported-functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Non-exported-functions-and-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications._validate_input_assembler-Tuple{NoThrowDAG, Nothing}" href="#TransformSpecifications._validate_input_assembler-Tuple{NoThrowDAG, Nothing}"><code>TransformSpecifications._validate_input_assembler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_validate_input_assembler(dag::NoThrowDAG, input_assembler::TransformSpecification)
_validate_input_assembler(dag::NoThrowDAG, ::Nothing)</code></pre><p>Confirm that an input_assembler, when called on all upstream outputs generated by <code>dag</code>, has access to all fields it needs to construct its input.</p><p>This validation assumes that the <code>dag</code> being validated against contains <strong>only</strong> outputs from upstream steps, an assumption that will be true on DAG construction (where this validation is called from). If called at other times, validation may succeed even though the <code>input_assembler</code> will fail when called in situ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow_dag.jl#L223-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.convert_spec-Union{Tuple{T}, Tuple{Type{T}, T}} where T" href="#TransformSpecifications.convert_spec-Union{Tuple{T}, Tuple{Type{T}, T}} where T"><code>TransformSpecifications.convert_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_spec(::Type{T}, input::T) where {T}
convert_spec(::Type{T}, input::T) where {T&lt;:Legolas.AbstractRecord}
convert_spec(spec::Type{&lt;:Legolas.AbstractRecord}, input)
convert_spec(spec, input)</code></pre><p>Return <code>input</code> interpreted as type <code>T</code>: is same as <code>identity</code> function if <code>input</code> is already of type <code>T</code>; otherwise, attempts to construct or <code>Base.convert</code>s the the output type from the input. Will throw if conversion fails or is otherwise undefined.</p><p>See also: <a href="#TransformSpecifications.transform!"><code>transform!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/transform.jl#L56-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.field_dict-Tuple{Type{&lt;:NoThrowResult}}" href="#TransformSpecifications.field_dict-Tuple{Type{&lt;:NoThrowResult}}"><code>TransformSpecifications.field_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field_dict(type::Type{&lt;:NoThrowResult})
field_dict(type)</code></pre><p>Return a <code>Dict</code> where keys are <code>fieldnames(type)</code> and the value of each key is that field&#39;s own type. Constructed by calling <code>field_dict_value</code> on each input field&#39;s type.</p><p>When <code>type</code> is a <code>NoThrowResult{T}</code>, generate mapping based on unwrapped type <code>T</code>.</p><p>To recurse into a specific type <code>MyType</code>, implement</p><pre><code class="nohighlight hljs">TransformSpecification.field_dict_value(t::Type{MyType}) = field_dict(t)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Use caution when implementing a <code>field_dict_value</code> for any type that isn&#39;t explicitly impossible to lead to recursion, as otherwise a stack overflow may occur.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow_dag.jl#L243-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.identity_no_throw_result-Tuple{Any}" href="#TransformSpecifications.identity_no_throw_result-Tuple{Any}"><code>TransformSpecifications.identity_no_throw_result</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">identity_no_throw_result(result) -&gt; NoThrowResult</code></pre><p>Return <code>NoThrowResult{T}</code> where <code>T=typeof(result)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow.jl#L315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.input_assembler-Tuple{Any}" href="#TransformSpecifications.input_assembler-Tuple{Any}"><code>TransformSpecifications.input_assembler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input_assembler(conversion_fn) -&gt; TransformSpecification{Dict{String,Any}, NamedTuple}</code></pre><p>Special transform used to convert the outputs of upstream steps in a <a href="#TransformSpecifications.NoThrowDAG"><code>NoThrowDAG</code></a> into a <code>NamedTuple</code> that can be converted into that type&#39;s input specification.</p><p><code>conversion_fn</code> must be a function that</p><ul><li>takes as input a Dictionary with keys that are the names of upstream steps, where   the value of each of these keys is the output of that upstream<em>step, as   specified by `output</em>specification(upstream_step)`.</li><li>returns a <code>NamedTuple</code> that can be converted, via <a href="#TransformSpecifications.convert_spec-Union{Tuple{T}, Tuple{Type{T}, T}} where T"><code>convert_spec</code></a>, to the   specification of an <code>AbstractTransformSpecification</code> that it is paired with   in a <a href="#TransformSpecifications.DAGStep"><code>DAGStep</code></a>.</li></ul><p>Note that the current implementation is a stopgap for a better-defined implementation defined in https://github.com/beacon-biosignals/TransformSpecifications.jl/issues/8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow_dag.jl#L27-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformSpecifications.is_input_assembler-Tuple{AbstractTransformSpecification}" href="#TransformSpecifications.is_input_assembler-Tuple{AbstractTransformSpecification}"><code>TransformSpecifications.is_input_assembler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_input_assembler(ts::AbstractTransformSpecification) -&gt; Bool</code></pre><p>Confirm that <code>ts</code> is an <a href="#TransformSpecifications.input_assembler-Tuple{Any}"><code>input_assembler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/TransformSpecifications.jl/blob/7e70f1f89c808103f835c36d8d782dc4df54d395/src/nothrow_dag.jl#L49-L53">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 9 August 2023 20:18">Wednesday 9 August 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
